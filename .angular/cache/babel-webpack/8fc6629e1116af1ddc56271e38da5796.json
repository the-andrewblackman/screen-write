{"ast":null,"code":"import { EditorSelection, MapMode, Prec, RangeSetBuilder, StateEffect, StateField } from '@codemirror/state';\nimport { foldCode, matchBrackets, indentUnit, ensureSyntaxTree, StringStream } from '@codemirror/language';\nimport * as View from '@codemirror/view';\nimport { runScopeHandlers, EditorView, Direction, ViewPlugin, Decoration, showPanel } from '@codemirror/view';\nimport { SearchQuery, setSearchQuery, RegExpCursor } from '@codemirror/search';\nimport { indentMore, indentLess, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorCharBackward, cursorCharLeft, insertNewlineAndIndent, indentSelection, undo, redo } from '@codemirror/commands';\n\n//@ts-check\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n/**\n * @typedef { import(\"./cm_adapter\").CodeMirror } CodeMirror\n * @typedef { import(\"./types\").CodeMirrorV} CodeMirrorV\n * @typedef { import(\"./types\").Pos } Pos\n * @typedef { import(\"./types\").CM5Range } CM5Range\n * @typedef { import(\"./types\").vimState } vimState \n * @typedef { import(\"./types\").ExFn } ExFn\n * @typedef { import(\"./types\").MotionArgs } MotionArgs\n * @typedef { import(\"./types\").ActionArgs } ActionArgs\n * @typedef { import(\"./types\").OperatorArgs } OperatorArgs\n * @typedef { import(\"./types\").vimKey } vimKey\n * @typedef { import(\"./types\").InputStateInterface } InputStateInterface\n */\n\n/** @arg {typeof import(\"./cm_adapter\").CodeMirror} CodeMirror */\nfunction initVim(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  /** @arg {CodeMirror} cm @arg {Pos} curStart @arg {Pos} curEnd */\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    // start and character position when no selection \n    // is the same in visual mode, and differs in 1 character in normal mode\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n    return {\n      start: curStart,\n      end: curEnd\n    };\n  }\n  /** @type {import(\"./types\").vimKeyMap} */\n  var defaultKeymap = [\n  // Key to key mapping. This goes first to make it possible to override\n  // existing mappings.\n  {\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: 'g<Up>',\n    type: 'keyToKey',\n    toKeys: 'gk'\n  }, {\n    keys: 'g<Down>',\n    type: 'keyToKey',\n    toKeys: 'gj'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  },\n  // ipad keyboard sends C-Esc instead of C-[\n  {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'keyToKey',\n    toKeys: 'i',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  },\n  // Motions\n  {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: \"g$\",\n    type: \"motion\",\n    motion: \"moveToEndOfDisplayLine\"\n  }, {\n    keys: \"g^\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: \"g0\",\n    type: \"motion\",\n    motion: \"moveToStartOfDisplayLine\"\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<register>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<register>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  },\n  // the next two aren't motions but must come before more general motion declarations\n  {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  },\n  // Operators\n  {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'gn',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gN',\n    type: 'motion',\n    motion: 'findAndSelectNextInclusive',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'gq',\n    type: 'operator',\n    operator: 'hardWrap'\n  }, {\n    keys: 'gw',\n    type: 'operator',\n    operator: 'hardWrap',\n    operatorArgs: {\n      keepCursor: true\n    }\n  },\n  // Operator-Motion dual commands\n  {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-u>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToStartOfLine',\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  },\n  //ignore C-w in normal mode\n  {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  },\n  // Actions\n  {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<register>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<register>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  },\n  // Handle Replace-mode as a special case of insert mode.\n  {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<register>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<register>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: '<C-r><register>',\n    type: 'action',\n    action: 'insertRegister',\n    context: 'insert',\n    isEdit: true\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'oneNormalCommand',\n    context: 'insert'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  },\n  // Text object motions\n  {\n    keys: 'a<register>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<register>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  },\n  // Search\n  {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  },\n  // Ex command\n  {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'omap',\n    shortName: 'om'\n  }, {\n    name: 'noremap',\n    shortName: 'no'\n  }, {\n    name: 'nnoremap',\n    shortName: 'nn'\n  }, {\n    name: 'vnoremap',\n    shortName: 'vn'\n  }, {\n    name: 'inoremap',\n    shortName: 'ino'\n  }, {\n    name: 'onoremap',\n    shortName: 'ono'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'mapclear',\n    shortName: 'mapc'\n  }, {\n    name: 'nmapclear',\n    shortName: 'nmapc'\n  }, {\n    name: 'vmapclear',\n    shortName: 'vmapc'\n  }, {\n    name: 'imapclear',\n    shortName: 'imapc'\n  }, {\n    name: 'omapclear',\n    shortName: 'omapc'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'startinsert',\n    shortName: 'start'\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'vglobal',\n    shortName: 'v'\n  }, {\n    name: 'delete',\n    shortName: 'd'\n  }, {\n    name: 'join',\n    shortName: 'j'\n  }, {\n    name: 'normal',\n    shortName: 'norm'\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n\n  /**\n   * Langmap\n   * Determines how to interpret keystrokes in Normal and Visual mode.\n   * Useful for people who use a different keyboard layout than QWERTY\n   */\n  var langmap = parseLangmap('');\n\n  /** @arg {CodeMirror} cm */\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    // @ts-ignore\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n\n  /** @arg {CodeMirror} cm */\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    // @ts-ignore\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n\n  /** @arg {CodeMirrorV} cm */\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }],\n    bigWordCharTest = [function (ch) {\n      return /\\S/.test(ch);\n    }];\n  var validMarks = ['<', '>'];\n  var validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\n  var latinCharRegex = /^\\w$/;\n  var upperCaseChars;\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n\n  /** @arg {CodeMirror} cm @arg {number} line */\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  /** @arg {string} k */\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  /** @arg {string} k */\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  /** @arg {string} k */\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  /** @arg {string} k */\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  /** @arg {string} k */\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  /** @arg {string} k */\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  /** @arg {any} val @arg {string | any[]} arr */\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @typedef {import(\"./types\").optionCallback} optionCallback */\n  /** @typedef {import(\"./types\").vimOption} vimOption */\n  /** @type {Object<string, vimOption>} */\n  var options = {};\n  /** \n   * @arg {string} name \n   * @arg {any} defaultValue \n   * @arg {string} type \n   * @arg {string[] } [aliases] \n   * @arg {optionCallback} [callback] \n   * */\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) {\n      type = 'string';\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  /**\n   * @arg {string} name \n   * @arg {any} value \n   * @arg {CodeMirrorV} [cm] \n   * @arg {{ scope?: any; } | undefined} [cfg] */\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        // Boolean options are set to true if value is not defined.\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n\n  /** \n   * @arg {string} name \n   * @arg {CodeMirrorV} [cm] \n   * @arg {{ scope?: any; } | undefined} [cfg] */\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      let local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      let local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n  /** @arg {string|undefined} name @arg {CodeMirrorV} [cm] */\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      let mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      let mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  defineOption('textwidth', 80, 'number', ['tw'], function (width, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (width === undefined) {\n      var value = cm.getOption('textwidth');\n      return value;\n    } else {\n      var column = Math.round( /**@type {any}*/width);\n      if (column > 1) {\n        cm.setOption('textwidth', column);\n      }\n    }\n  });\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    /** @arg {CodeMirror} cm  @arg {any} oldCur @arg {any} newCur */\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      /** @arg {Pos} cursor */\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        // avoid recording redundant cursor position\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    /** @arg {CodeMirror} cm  @arg {number} offset */\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      // skip marks that are temporarily removed from text buffer\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          // skip marks that are the same as current position\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    /** @arg {CodeMirror} cm @arg {number} offset */\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined,\n      //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n\n  /** \n   * Returns an object to track the changes associated insert mode.  It\n   * clones the object that is passed in, or creates an empty object one if\n   * none is provided.\n   * @arg {import(\"./types\").InsertModeChanges | undefined} [c]\n   * @returns {import(\"./types\").InsertModeChanges} \n   */\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      // Copy construction\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      // Change list\n      changes: [],\n      // Set to true on change, false on cursorActivity.\n      expectCursorActivityForChange: false\n    };\n  };\n  class MacroModeState {\n    constructor() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    exitMacroRecordMode() {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    }\n    enterMacroRecordMode(cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {\n            class: 'cm-vim-message'\n          }, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {\n            bottom: true\n          });\n        }\n        this.isRecording = true;\n      }\n    }\n  }\n  /**\n   * @arg Codemirror\n   * @return {vimState}\n   */\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      // Store instance state in the CodeMirror object.\n      cm.state.vim = {\n        inputState: new InputState(),\n        // Vim's input state that triggered the last edit, used to repeat\n        // motions and operators with '.'.\n        lastEditInputState: undefined,\n        // Vim's action command before the last edit, used to repeat actions\n        // with '.' and insert mode repeat.\n        lastEditActionCommand: undefined,\n        // When using jk for navigation, if you move from a longer line to a\n        // shorter line, the cursor may clip to the end of the shorter line.\n        // If j is pressed again and cursor goes to the next line, the\n        // cursor should go back to its horizontal position on the longer\n        // line if it can. This is to keep track of the horizontal position.\n        lastHPos: -1,\n        // Doing the same with screen-position for gj/gk\n        lastHSPos: -1,\n        // The last motion command run. Cleared if a non-motion command gets\n        // executed in between.\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeReturn: false,\n        // Repeat count for changes made in insert mode, triggered by key\n        // sequences like 3,i. Only exists when insertMode is true.\n        insertModeRepeat: undefined,\n        visualMode: false,\n        // If we are in visual line mode. No effect if visualMode is false.\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        // Buffer-local/window-local values of vim options.\n        options: {},\n        // Whether the next character should be interpreted literally\n        // Necassary for correct implementation of f<character>, r<character> etc.\n        // in terms of langmaps.\n        expectLiteralNext: false\n      };\n    }\n    return cm.state.vim;\n  }\n  /**\n   * @type { \n      {\n        macroModeState: MacroModeState;\n        registerController: RegisterController;\n        searchHistoryController: HistoryController;\n        jumpList: any;\n        exCommandHistoryController: HistoryController; \n        lastCharacterSearch: any; \n        query?: any;\n        isReversed?: any;\n        lastSubstituteReplacePart: any;\n        searchQuery?: null; \n        searchIsReversed?: boolean; \n      }\n    }\n  */\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      // The current search query.\n      searchQuery: null,\n      // Whether we are searching backwards.\n      searchIsReversed: false,\n      // Replace part of the last substituted pattern\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      // Recording latest f, t, F or T motion command.\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      // search history buffer\n      searchHistoryController: new HistoryController(),\n      // ex Command history buffer\n      exCommandHistoryController: new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  /** @type {number | undefined|false} */\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function () {\n      // TODO: Convert keymap into dictionary format for fast lookup.\n    },\n    // Testing hook, though it might be useful to expose the register\n    // controller anyway.\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    // Testing hook.\n    resetVimGlobalState_: resetVimGlobalState,\n    // Testing hook.\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n    // Testing hook.\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    /**@type {(lhs: string, rhs: string, ctx: string) => void} */\n    map: function (lhs, rhs, ctx) {\n      // Add user defined key bindings.\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    /**@type {(lhs: string, ctx: string) => any} */\n    unmap: function (lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    // Non-recursive map function.\n    // NOTE: This will not create mappings to key maps that aren't present\n    // in the default key map. See TODO at bottom of function.\n    /**@type {(lhs: string, rhs: string, ctx: string) => void} */\n    noremap: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    // Remove all user-defined mappings for the provided context.\n    /**@arg {string} [ctx]} */\n    mapclear: function (ctx) {\n      // Partition the existing keymap into user-defined and true defaults.\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        // If a specific context is being cleared, we need to keep mappings\n        // from all other contexts.\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              // `mapping` applies to all contexts so create keymap copies\n              // for each context except the one being cleared.\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = Object.assign({}, mapping);\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    /**@type {(name: string, prefix: string|undefined, func: ExFn) => void} */\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    /**@type {(cm: CodeMirror, key: string, origin: string) => undefined | boolean} */\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n    /**\n     * This is the outermost function called by CodeMirror, after keys have\n     * been mapped to their Vim equivalents.\n     *\n     * Finds a command based on the key (and cached keys if there is a\n     * multi-key sequence). Returns `undefined` if no key is matched, a noop\n     * function if a partial match is found (multi-key), and a function to\n     * execute the bound command if a a key is matched. The function always\n     * returns true.\n     */\n    /**@type {(cm_: CodeMirror, key: string, origin?: string| undefined) => (() => boolean) | undefined} */\n    findKey: function (cm_, key, origin) {\n      var vim = maybeInitVimState(cm_);\n      var cm = /**@type {CodeMirrorV}*/cm_;\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            // Get back to normal mode.\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            // Get back to normal mode.\n            exitInsertMode(cm);\n          } else {\n            // We're already in normal mode. Let '<Esc>' be handled normally.\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        var changeQueue = vim.inputState.changeQueue;\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = keysAreChars && window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer.length) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            if (!changeQueue || changeQueue.removed.length != selections.length) changeQueue = vim.inputState.changeQueue = new ChangeQueue();\n            changeQueue.inserted += key;\n            for (var i = 0; i < selections.length; i++) {\n              var from = cursorMin(selections[i].anchor, selections[i].head);\n              var to = cursorMax(selections[i].anchor, selections[i].head);\n              var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n              changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n            }\n          }\n          return !keysAreChars;\n        }\n        vim.expectLiteralNext = false;\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (match.command && changeQueue) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(changeQueue.removed[i] || \"\", offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        if (!match.command) clearInputState(cm);\n        return match.command;\n      }\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          // multikey operators act linewise by repeating only the last character\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          return true;\n        } else if (match.type == 'clear') {\n          clearInputState(cm);\n          return true;\n        }\n        vim.expectLiteralNext = false;\n        vim.inputState.keyBuffer.length = 0;\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher && keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return !vim.insertMode && key.length === 1 ? function () {\n          return true;\n        } : undefined;\n      } else if (command === true) {\n        // TODO: Look into using CodeMirror's multi-key handling.\n        // Return no-op since we are caching the key. Counts as handled, but\n        // don't want act on it just yet.\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          return cm.operation(function () {\n            // @ts-ignore\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(cm, command.toKeys, command);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              // clear VIM state in case it's in a bad state.\n              // @ts-ignore\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n  var keyToKeyStack = [];\n  var noremap = false;\n  var virtualPrompt;\n  function sendKeyToPrompt(key) {\n    if (key[0] == \"<\") {\n      var lowerKey = key.toLowerCase().slice(1, -1);\n      var parts = lowerKey.split('-');\n      lowerKey = parts.pop() || '';\n      if (lowerKey == 'lt') key = '<';else if (lowerKey == 'space') key = ' ';else if (lowerKey == 'cr') key = '\\n';else if (vimToCmKeyMap[lowerKey]) {\n        var value = virtualPrompt.value;\n        var event = {\n          key: vimToCmKeyMap[lowerKey],\n          target: {\n            value: value,\n            selectionEnd: value.length,\n            selectionStart: value.length\n          }\n        };\n        if (virtualPrompt.onKeyDown) {\n          virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n        }\n        if (virtualPrompt && virtualPrompt.onKeyUp) {\n          virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n        }\n        return;\n      }\n    }\n    if (key == '\\n') {\n      var prompt = virtualPrompt;\n      virtualPrompt = null;\n      prompt.onClose && prompt.onClose(prompt.value);\n    } else {\n      virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n    function close(value) {\n      if (typeof value == 'string') {\n        virtualPrompt.value = value;\n      } else {\n        virtualPrompt = null;\n      }\n    }\n  }\n  function doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    // prevent infinite recursion.\n    if (fromKey) {\n      if (keyToKeyStack.indexOf(fromKey) != -1) return;\n      keyToKeyStack.push(fromKey);\n      noremap = fromKey.noremap != false;\n    }\n    try {\n      var vim = maybeInitVimState(cm);\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n      var match;\n      // Pull off one command key, which is either a single character\n      // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n      while (match = keyRe.exec(keys)) {\n        var key = match[0];\n        var wasInsert = vim.insertMode;\n        if (virtualPrompt) {\n          sendKeyToPrompt(key);\n          continue;\n        }\n        var result = vimApi.handleKey(cm, key, 'mapping');\n        if (!result && wasInsert && vim.insertMode) {\n          if (key[0] == \"<\") {\n            var lowerKey = key.toLowerCase().slice(1, -1);\n            var parts = lowerKey.split('-');\n            lowerKey = parts.pop() || '';\n            if (lowerKey == 'lt') key = '<';else if (lowerKey == 'space') key = ' ';else if (lowerKey == 'cr') key = '\\n';else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n              // todo support codemirror keys in insertmode vimToCmKeyMap\n              key = vimToCmKeyMap[lowerKey];\n              sendCmKey(cm, key);\n              continue;\n            } else {\n              key = key[0];\n              keyRe.lastIndex = match.index + 1;\n            }\n          }\n          cm.replaceSelection(key);\n        }\n      }\n    } finally {\n      keyToKeyStack.pop();\n      noremap = keyToKeyStack.length ? noremapBefore : false;\n      if (!keyToKeyStack.length && virtualPrompt) {\n        var promptOptions = virtualPrompt;\n        virtualPrompt = null;\n        showPrompt(cm, promptOptions);\n      }\n    }\n  }\n  var specialKey = {\n    Return: 'CR',\n    Backspace: 'BS',\n    'Delete': 'Del',\n    Escape: 'Esc',\n    Insert: 'Ins',\n    ArrowLeft: 'Left',\n    ArrowRight: 'Right',\n    ArrowUp: 'Up',\n    ArrowDown: 'Down',\n    Enter: 'CR',\n    ' ': 'Space'\n  };\n  var ignoredKeys = {\n    Shift: 1,\n    Alt: 1,\n    Command: 1,\n    Control: 1,\n    CapsLock: 1,\n    AltGraph: 1,\n    Dead: 1,\n    Unidentified: 1\n  };\n  var vimToCmKeyMap = {};\n  'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function (x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()] = vimToCmKeyMap[x.toLowerCase()] = x;\n  });\n  function vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key]) return;\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n    if (e.altKey) {\n      name += 'A-';\n    }\n    if (e.metaKey) {\n      name += 'M-';\n    }\n    // on mac many characters are entered as option- combos\n    // (e.g. on swiss keyboard { is option-8)\n    // so we ignore lonely A- modifier for keypress event on mac\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n      name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl != false || !name) key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code?.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n    name += key;\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n    return name;\n  }\n  // langmap support\n  function updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n      langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n  }\n  /** \n   *  From :help langmap\n   *  The 'langmap' option is a list of parts, separated with commas.  Each\n   *      part can be in one of two forms:\n   *      1.  A list of pairs.  Each pair is a \"from\" character immediately\n   *          followed by the \"to\" character.  Examples: \"aA\", \"aAbBcC\".\n   *      2.  A list of \"from\" characters, a semi-colon and a list of \"to\"\n   *          characters.  Example: \"abc;ABC\"\n   * @arg {string} langmapString\n   * @returns {{string: string, keymap: Record<string, string>, remapCtrl?: boolean}}\n   */\n  function parseLangmap(langmapString) {\n    let keymap = {} /**@type {Record<string, string>}*/;\n    if (!langmapString) return {\n      keymap: keymap,\n      string: ''\n    };\n    function getEscaped(list) {\n      return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(part => {\n      if (!part) return;\n      const semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n      if (semicolon.length == 3) {\n        const from = getEscaped(semicolon[1]);\n        const to = getEscaped(semicolon[2]);\n        if (from.length !== to.length) return; // skip over malformed part\n        for (let i = 0; i < from.length; ++i) keymap[from[i]] = to[i];\n      } else if (semicolon.length == 1) {\n        const pairs = getEscaped(part);\n        if (pairs.length % 2 !== 0) return; // skip over malformed part\n        for (let i = 0; i < pairs.length; i += 2) keymap[pairs[i]] = pairs[i + 1];\n      }\n    });\n    return {\n      keymap: keymap,\n      string: langmapString\n    };\n  }\n  defineOption('langmap', undefined, 'string', ['lmap'], function (name, cm) {\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      return langmap.string;\n    } else {\n      updateLangmap(name);\n    }\n  });\n\n  // Represents the current input state.\n  class InputState {\n    constructor() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n      this.changeQueue = null; // For restoring text used by insert mode keybindings\n    }\n    pushRepeatDigit(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    }\n    getRepeat() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    }\n  }\n\n  /** @arg {CodeMirrorV} cm  @arg {string} [reason] */\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n  function ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n  }\n\n  /**\n   * Register stores information about copy and paste registers.  Besides\n   * text, a register must store whether it is linewise (i.e., when it is\n   * pasted, should it insert itself into a new line, or should the text be\n   * inserted at the cursor position.)\n   */\n  class Register {\n    constructor(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    setText(text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    pushText(text, linewise) {\n      // if this register has ever been set to linewise, use linewise.\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    }\n    pushInsertModeChanges(changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    }\n    pushSearchQuery(query) {\n      this.searchQueries.push(query);\n    }\n    clear() {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    }\n    toString() {\n      return this.keyBuffer.join('');\n    }\n  }\n\n  /**\n   * Defines an external register.\n   *\n   * The name should be a single character that will be used to reference the register.\n   * The register should support setText, pushText, clear, and toString(). See Register\n   * for a reference implementation.\n   * @arg {string} name\n   * @arg {Register} register\n   */\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    if (registers[name]) {\n      throw Error('Register already defined ' + name);\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  /**\n   * vim registers allow you to keep many independent copy and paste buffers.\n   * See http://usevim.com/2012/04/13/registers/ for an introduction.\n   *\n   * RegisterController keeps the state of all the registers.  An initial\n   * state may be passed in.  The unnamed register '\"' will always be\n   * overridden.\n   */\n  class RegisterController {\n    /** @arg {Object<string, Register>} registers */\n    constructor(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    pushText(registerName, operator, text, linewise, blockwise) {\n      // The black hole register, \"_, means delete/yank to nowhere.\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      // Lowercase and uppercase registers refer to the same register.\n      // Uppercase just means append.\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n      // if no register/an invalid register was specified, things go to the\n      // default registers\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            // The 0 register contains the text from the most recent yank.\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              // Delete less than 1 line. Update the small delete register.\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              // Shift down the contents of the numbered registers and put the\n              // deleted text into register 1.\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        // Make sure the unnamed register is set to what just happened\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      // If we've gotten to this point, we've actually specified a register\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+') {\n        navigator.clipboard.writeText(text);\n      }\n      // The unnamed register always has the same value as the last used\n      // register.\n      this.unnamedRegister.setText(register.toString(), linewise);\n    }\n    /**\n     * Gets the register named @name.  If one of @name doesn't already exist,\n     * create it.  If @name is invalid, return the unnamedRegister.\n     * @arg {string} [name]\n     */\n    getRegister(name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    }\n    /**@type {{(name: any): name is string}} */\n    isValidRegister(name) {\n      return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    }\n    shiftNumericRegisters_() {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  }\n  class HistoryController {\n    constructor() {\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n    // the input argument here acts a user entered prefix for a small time\n    // until we start autocompletion in which case it is the autocompleted.\n    nextMatch(input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      // should return the user input in case we reach the end of buffer.\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      // return the last autocompleted query or exCommand as it is.\n      if (i < 0) return input;\n    }\n    pushInput(input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    }\n    reset() {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  }\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial',\n          expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n        };\n      }\n      var bestMatch;\n      // @ts-ignore\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {\n          type: 'clear'\n        };\n        inputState.selectedCharacter = character;\n      }\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {vimKey} command\n     */\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").motionCommand|import(\"./types\").operatorMotionCommand} command\n     */\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = /**@type {MotionArgs}*/copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").operatorCommand|import(\"./types\").operatorMotionCommand} command\n     */\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          // Typing an operator twice like 'dd' makes the operator operate\n          // linewise\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true,\n            repeat: 1\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          // 2 different operators in a row doesn't make sense.\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        // Operating on a selection in visual mode. We don't need a motion.\n        this.evalInput(cm, vim);\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").operatorMotionCommand} command\n     */\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        // Operator motions may have special behavior in visual mode.\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").actionCommand} command\n     */\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = /**@type {ActionArgs}*/copyArgs(command.actionArgs) || {\n        repeat: 1\n      };\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      // Actions may or may not have motions and operators. Do these first.\n      if (command.operator) {\n        // @ts-ignore\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        // @ts-ignore\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    /** @arg {CodeMirrorV} cm @arg {vimState} vim @arg {import(\"./types\").searchCommand} command*/\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        // Search depends on SearchCursor.\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      /** @arg {string} query  @arg {boolean} ignoreCase  @arg {boolean} smartCase */\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          keys: '',\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n      /** @arg {string} query */\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      /** \n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e \n       * @arg {any} query \n       * @arg {(arg0: any) => void} close \n       */\n      function onPromptKeyUp(e, query, close) {\n        var keyName = vimKeyFromEvent(e),\n          up,\n          offset;\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          // Swallow bad regexes for incremental search.\n        }\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      /** @arg {KeyboardEvent} e  @arg {string} query  @arg {(arg0?: string) => void} close */\n      function onPromptKeyDown(e, query, close) {\n        var keyName = vimKeyFromEvent(e);\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' || keyName == '<BS>' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == '<C-u>') {\n          // Ctrl-U clears input.\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            let query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: '(JavaScript regexp)',\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, {\n            noSymbol: true\n          });\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, {\n              noSymbol: false\n            });\n            isKeyword = false;\n          }\n          if (!word) {\n            showConfirm(cm, 'No word under cursor');\n            clearInputState(cm);\n            return;\n          }\n          let query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n\n          // cachedCursor is used to save the old position of the cursor\n          // when * or # causes vim to seek for the nearest word and shift\n          // the cursor before entering the motion.\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").exCommand | import(\"./types\").keyToExCommand} command\n     */\n    processEx: function (cm, vim, command) {\n      /**@arg {string} input*/\n      function onPromptClose(input) {\n        // Give the prompt some time to close so that if processCommand shows\n        // an error, the elements don't overlap.\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n      /**\n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e\n       * @arg {string} input\n       * @arg {(arg0?: string) => void} close\n       */\n      function onPromptKeyDown(e, input, close) {\n        var keyName = vimKeyFromEvent(e),\n          up,\n          offset;\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' || keyName == '<BS>' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == '<C-u>') {\n          // Ctrl-U clears input.\n          CodeMirror.e_stop(e);\n          close('');\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        // Handle user defined Ex to Ex mappings\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    /**@arg {CodeMirrorV} cm   @arg {vimState} vim */\n    evalInput: function (cm, vim) {\n      // If the motion command is set, execute both the operator and motion.\n      // Otherwise return.\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      /** @type {MotionArgs}*/\n      var motionArgs = inputState.motionArgs || {\n        repeat: 1\n      };\n      var operator = inputState.operator;\n      /** @type {OperatorArgs}*/\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      // TODO: Make sure cm and vim selections are identical outside visual mode.\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        // If repeatOverride is specified, that takes precedence over the\n        // input state's repeat. Used by Ex mode and can be user defined.\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        // If there is a character input, stick it in all of the arg arrays.\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          var jumpList = vimGlobalState.jumpList;\n          // if the current motion is # or *, use cachedCursor\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            // @ts-ignore\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            // @ts-ignore\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        // TODO: Handle null returns from motion commands better.\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          // Replaying a visual mode operation\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            // Linewise Visual mode: The same number of lines.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            // Blockwise Visual mode: The same number of lines and columns.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            // Normal Visual mode within one line: The same number of characters.\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            // Normal Visual mode with several lines: The same number of lines, in the\n            // last line the same number of characters as in the last line the last time.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise;\n        /** @type {'block'|'line'|'char'}*/\n        var mode;\n        var cmSel;\n        if (vim.visualMode) {\n          // Init visual op\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              // Linewise operators in visual block mode extend to end of line\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          // Init motion op\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        // Keep track of linewise as it affects how paste and change behave.\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    /**@arg {vimState} vim  @arg {InputStateInterface} inputState, @arg {import(\"./types\").actionCommand} [actionCommand] */\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n\n  /**\n   * All of the functions below return Cursor objects.\n   * @type {import(\"./types\").vimMotions}}\n   */\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      // Expands forward to end of line, and then to next line if repeat is\n      // >1. Does not handle backward motion!\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      // If search is initiated with ? instead of /, negate direction.\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    /**\n     * Find and select the next occurrence of the search query. If the cursor is currently\n     * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n     * appropriate direction.\n     *\n     * This differs from `findNext` in the following ways:\n     *\n     * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n     * 2. If the cursor is currently inside a search match, this selects the current match\n     *    instead of the next match.\n     * 3. If there is no associated operator, this will turn on visual mode.\n     */\n    findAndSelectNextInclusive: function (cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n\n      // next: [from, to] | null\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n      // No matches.\n      if (!next) {\n        return;\n      }\n\n      // If there's an operator that will be executed, return the selection.\n      if (prevInputState.operator) {\n        return next;\n      }\n\n      // At this point, we know that there is no accompanying operator -- let's\n      // deal with visual mode in order to select an appropriate match.\n\n      var from = next[0];\n      // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n      // the resulting selection is extended by 1 char. Let's shrink it so that only the\n      // match is selected.\n      var to = new Pos(next[1].line, next[1].ch - 1);\n      if (vim.visualMode) {\n        // If we were in visualLine or visualBlock mode, get out of it.\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\"\n          });\n        }\n\n        // If we're currently in visual mode, we should extend the selection to include\n        // the search result.\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n            return [anchor, from];\n          }\n        }\n      } else {\n        // Let's turn visual mode on.\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\"\n        });\n      }\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter || \"\");\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ?\n          // @ts-ignore\n          cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n          if (isWrongDirection) {\n            continue;\n          }\n          // @ts-ignore\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ?\n          // @ts-ignore\n          cursorIsBetween(cursor, mark, best) :\n          // @ts-ignore\n          cursorIsBetween(best, mark, cursor);\n          if (equal || between) {\n            // @ts-ignore\n            best = mark;\n          }\n        }\n      }\n      if (motionArgs.linewise) {\n        // Vim places the cursor on the first non-whitespace character of\n        // the line if there is one, else it places the cursor at the end\n        // of the line, regardless of whether a mark was found.\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      // Depending what our last motion was, we may want to do different\n      // things. If our last motion was moving vertically, we want to\n      // preserve the HPos from our last horizontal move.  If our last motion\n      // was going to the end of a line, moving vertically we should go to\n      // the end of the line, etc.\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n      if (hasMarkedText) {\n        line = posV.line;\n        endCh = posV.ch;\n      }\n      // Vim go to line begin or line end when cursor at first/last line and\n      // move to previous/next line is triggered.\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), 'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      // CodeMirror only exposes functions that move the cursor page down, so\n      // doing this bad hack to move the cursor and move it back. evalInput\n      // will move the cursor to where it should be in the end.\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir).start;\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return motionArgs.selectedCharacter && findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      // repeat is equivalent to which column we want to move to!\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      // Go to the start of the line where the text begins, or the end for\n      // whitespace-only lines\n      var cursor = head;\n      return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        // Only include angle brackets in analysis if they are being matched.\n        var re = symbol === '<' || symbol === '>' ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n        var matched = cm.findMatchingBracket(new Pos(line, ch), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n      /** @type{Object<string, string>} */\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      /** @type{Object<string, boolean>} */\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter || \"\";\n      // 'b' refers to  '()' block.\n      // 'B' refers to  '{}' block.\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n\n      // Inclusive is the difference between a and i\n      // TODO: Instead of using the additional text object map to perform text\n      //     object operations, merge the map into the defaultKeyMap and use\n      //     motionArgs to define behavior. Define separate entries for 'aw',\n      //     'iw', 'a[', 'i[', etc.\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp, move;\n      if (mirroredPairs[character]) {\n        move = true;\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n        if (!tmp) {\n          var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n          if (sc.find()) {\n            // @ts-ignore\n            tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n          }\n        }\n      } else if (selfPaired[character]) {\n        move = true;\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W' || character === 'w') {\n        var repeat = motionArgs.repeat || 1;\n        while (repeat-- > 0) {\n          var repeated = expandWordUnderCursor(cm, {\n            inclusive,\n            innerWord: !inclusive,\n            bigWord: character === 'W',\n            noSymbol: character === 'W',\n            multiline: true\n          }, tmp && tmp.end);\n          if (repeated) {\n            if (!tmp) tmp = repeated;\n            tmp.end = repeated.end;\n          }\n        }\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        // account for cursor on end of sentence symbol\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch]) && isWhiteSpaceString(cm.getLine(end.line)[end.ch - 1])) {\n          start = {\n            line: start.line,\n            ch: start.ch + 1\n          };\n        }\n        tmp = {\n          start: start,\n          end: end\n        };\n      }\n      if (!tmp) {\n        // No valid text object, don't move.\n        return null;\n      }\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end, move);\n      }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n\n  /** @arg {string} name  @arg {import(\"./types\").MotionFn} fn */\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  /** @arg {string} val @arg {number} times */\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  /**\n   * An operator acts on a text selection. It receives the list of selections\n   * as input. The corresponding CodeMirror selection is guaranteed to\n   * match the input selection.\n   */\n  /** @type {import(\"./types\").vimOperators} */\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n        head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState;\n        if (lastState?.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        if (args.linewise) {\n          anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n          if (head.line > anchor.line) {\n            head = new Pos(head.line - 1, Number.MAX_VALUE);\n          }\n        }\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    delete: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          // Special case for dd on last line (and first line).\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n      var repeat = vim.visualMode ? args.repeat || 0 : 1;\n      if (cm.indentMore) {\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function (cm, operatorArgs, ranges, oldAnchor) {\n      if (!cm.hardWrap) return;\n      var from = ranges[0].anchor.line;\n      var to = ranges[0].head.line;\n      if (operatorArgs.linewise) to--;\n      var endRow = cm.hardWrap({\n        from: from,\n        to: to\n      });\n      if (endRow > from && operatorArgs.linewise) endRow--;\n      return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n\n  /** @arg {string} name  @arg {import(\"./types\").OperatorFn} fn */\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  /** @type {import(\"./types\").vimActions} */\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n    },\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center':\n          y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter || \"\";\n      var repeat = actionArgs.repeat || 1;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        // Handle Replace-mode as a special case of insert mode.\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        // Only record if not replaying.\n        cm.on('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(head, {\n          insertLeft: true\n        });\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      // TODO: The repeat should actually select number of characters/lines\n      //     equal to the repeat times the size of the previous visual\n      //     operation.\n      if (!vim.visualMode) {\n        // Entering visual mode\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine != !!actionArgs.linewise || vim.visualBlock != !!actionArgs.blockwise) {\n        // Toggling between modes\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          // If the marks have been destroyed due to edits, do nothing.\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        // Repeat is the number of lines to join. Minimum 2 lines.\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, new Pos(curStart.line, finalCh), new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        // Special case for inserting newline before start of document.\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      if (actionArgs.registerName === '+') {\n        navigator.clipboard.readText().then(value => {\n          this.continuePaste(cm, actionArgs, vim, value, register);\n        });\n      } else {\n        var text = register.toString();\n        this.continuePaste(cm, actionArgs, vim, text, register);\n      }\n    },\n    continuePaste: function (cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        // length that considers tabs and tabSize\n        var whitespaceLength = function ( /** @type {string} */str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        // @ts-ignore\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        // chomp last newline b/c don't want it to match /^\\s*/gm\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        // @ts-ignore\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        // @ts-ignore\n        text = text.split('\\n');\n        if (linewise) {\n          // @ts-ignore\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          // @ts-ignore\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          // Move the newline at the end to the start instead, and paste just\n          // before the newline character of the line we are on right now.\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      if (vim.visualMode) {\n        //  save the pasted text for reselection if the need arises\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        // save the curEnd marker before it get cleared due to cm.replaceRange.\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        // push the previously selected text to unnamed register\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          // first delete the selected text\n          cm.replaceSelections(emptyStrings);\n          // Set new selections as per the block length of the yanked text\n          selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          // @ts-ignore\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        // restore the curEnd marker\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          // @ts-ignore\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          // Now fine tune the cursor to where we want it.\n          if (linewise) {\n            var line = actionArgs.after ? cur.line + 1 : cur.line;\n            curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n          } else {\n            curPosFinal = copyCursor(cur);\n            if (!/\\n/.test(text)) {\n              curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n            }\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      var text = register && register.toString();\n      if (text) {\n        cm.replaceSelection(text);\n      }\n    },\n    oneNormalCommand: function (cm, actionArgs, vim) {\n      exitInsertMode(cm, true);\n      vim.insertModeReturn = true;\n      CodeMirror.on(cm, 'vim-command-done', function handler() {\n        if (vim.visualMode) return;\n        if (vim.insertModeReturn) {\n          vim.insertModeReturn = false;\n          if (!vim.insertMode) {\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        }\n        CodeMirror.off(cm, 'vim-command-done', handler);\n      });\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      if (markName) updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter || \"\";\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        // special case, where vim help says to replace by just one line-break\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        // replace all surrogate characters with selected character\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        //replace all characters in range by selected, but keep linebreaks\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          // Tabs are split in visua block before replacing\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          var replaceWithStrings = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStrings);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      // @ts-ignore\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        // @ts-ignore\n        var from = new Pos(cur.line, start);\n        // @ts-ignore\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      // @ts-ignore\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: function (cm, actionArgs) {\n      exitInsertMode(cm);\n    }\n  };\n\n  /** @arg {string } name  @arg {import(\"./types\").ActionFn} fn */\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  /*\n    * Below are miscellaneous utility functions used by vim.js\n    */\n\n  /**\n   * Clips cursor to ensure that line is within the buffer's range\n   * and is not inside surrogate pair\n   * If includeLineBreak is true, then allow cur.ch == lineLength.\n   * @arg {CodeMirrorV} cm \n   * @arg {Pos} cur \n   * @arg {Pos} [oldCur]\n   * @return {Pos}\n   */\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    // prevent cursor from entering surrogate pair\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n        direction = -1;\n      }\n      ch += direction;\n      if (ch > maxCh) ch -= 2;\n    }\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    // Partial matches are not applied. They inform the key handler\n    // that the current key sequence is a subsequence of a valid key\n    // sequence, so that the key buffer is not cleared.\n    if (inputState.operator) context = \"operatorPending\";\n    var match,\n      partial = [],\n      full = [];\n    // if currently expanded key comes from a noremap, searcg only in default keys\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n      if (match == 'partial') {\n        partial.push(command);\n      }\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  /** @arg {string} pressed  @arg {string} mapped  @return {'full'|'partial'|false}*/\n  function commandMatch(pressed, mapped) {\n    const isLastCharacter = mapped.slice(-11) == '<character>';\n    const isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n      // Last character matches anything.\n      var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  /** @arg {string} keys */\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n        case '<S-CR>':\n          selectedCharacter = '\\n';\n          break;\n        case '<Space>':\n        case '<S-Space>':\n          selectedCharacter = ' ';\n          break;\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  /** @arg {CodeMirror} cm   @arg {{ (cm: CodeMirror): void }} fn   @arg {number} repeat */\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  /** @arg {Pos} cur   @return {Pos}*/\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  /** @arg {Pos} cur1 @arg {Pos} cur2  @return {boolean} */\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  /** @arg {Pos} cur1  @arg {Pos} cur2 @return {boolean}*/\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  /** @arg {Pos} cur1 @arg {Pos} cur2  @return {Pos}*/\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      // @ts-ignore\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  /** @arg {Pos} cur1  @arg {Pos} cur2  @return {Pos} */\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      // @ts-ignore\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  /** @arg {Pos} cur1   @arg {Pos} cur2  @arg {Pos} cur3  @return {boolean}*/\n  function cursorIsBetween(cur1, cur2, cur3) {\n    // returns true if cur2 is between cur1 and cur3.\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  /** @arg {CodeMirror} cm  @arg {number} lineNum */\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  /** @arg {string} s */\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  /** @arg {string} s */\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  /** @arg {CodeMirror} cm  @arg {number} lineNum  @arg {number} column */\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  // This functions selects a rectangular block\n  // of text with selectionEnd as any of its corner\n  // Height of block:\n  // Difference in selectionEnd.line and first/last selection.line\n  // Width of the block:\n  // Distance between selectionEnd.ch and any(first considered here) selection.ch\n  /** @arg {CodeMirror} cm  @arg {Pos} selectionEnd */\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  /** @arg {CodeMirror} cm  @arg {any} head  @arg {number} height */\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n    cm.setSelections(sel, 0);\n  }\n  // getIndex returns the index of the cursor in the selections.\n  /** @arg {string | any[]} ranges  @arg {any} cursor  @arg {string | undefined} [end] */\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /** @arg {CodeMirror} cm  @arg {vimState} vim */\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    /** @return {[Pos,Pos]} */\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        // selectBlock creates a 'proper' rectangular block.\n        // We do not want that in all cases, so we manually set selections.\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      // In case of replaying the action.\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  // Updates the previous selection with the current selection's values. This\n  // should only be called in visual mode.\n  /** @arg {CodeMirror} cm @arg {vimState} vim */\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    // To accommodate the effect of lastPastedText in the last selection\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n  /** @arg {CodeMirrorV} cm @arg {Pos} start @arg {Pos} end @returns {[Pos, Pos]} */\n  function expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start : sel.head;\n    var anchor = move ? start : sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  /**\n   * Updates the CodeMirror selection to match the provided vim selection.\n   * If no arguments are given, it uses the current vim selection state.\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState[\"sel\"]} [sel] \n   * @arg {\"char\"|\"line\"|\"block\" | undefined} [mode]\n   */\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    if (!mode) {\n      mode = vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    }\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {import(\"./types\").CM5RangeInterface} sel\n   * @arg {\"char\"|\"line\"|\"block\"} mode \n   * @arg {boolean|undefined} [exclusive] \n   * @return {{ranges: any, primary: number}}\n   */\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n        fromCh = anchor.ch,\n        bottom = Math.max(anchor.line, head.line),\n        toCh = head.ch;\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n    throw \"never happens\";\n  }\n  /** @arg {CodeMirror} cm */\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      // Small corner case when only 1 character is selected. The \"real\"\n      // head is the left of head and anchor.\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n\n  /**\n   * If moveHead is set to false, the CodeMirror selection will not be\n   * touched. The caller assumes the responsibility of putting the cursor\n   * in the right place.\n   * @arg {CodeMirrorV} cm \n   * @arg {boolean} [moveHead]\n   */\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n  }\n\n  /** \n   * Remove any trailing newlines from the selection. For\n   * example, with the caret at the start of the last word on the line,\n   * 'dw' should word, but not the newline, while 'w' should advance the\n   * caret to the first character of the next line.\n   * @arg {CodeMirror} cm\n   * @arg {Pos} curStart\n   * @arg {Pos} curEnd\n   */\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    // Only clip if the selection ends with trailing newline + whitespace\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      // We know this is all whitespace.\n      lines.pop();\n\n      // Cases:\n      // 1. Last word is an empty line - do not clip the trailing '\\n'\n      // 2. Last word is not an empty line - clip the trailing '\\n'\n      // Find the line containing the last word, and clip all whitespace up\n      // to it.\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      // If the last word is not an empty line, clip an additional newline\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  // Expand the selection to line ends.\n  /** @arg {CodeMirror} _cm  @arg {Pos} curStart  @arg {Pos} curEnd */\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  /** @arg {string} [text] */\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  /** \n   * @arg {CodeMirror} cm \n   * @arg {{inclusive?: boolean, innerWord?: boolean, bigWord?: boolean, noSymbol?: boolean, multiline?: boolean}} options\n   * @arg {Pos} [cursor]\n   **/\n  function expandWordUnderCursor(cm, {\n    inclusive,\n    innerWord,\n    bigWord,\n    noSymbol,\n    multiline\n  }, cursor) {\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n    var wordOnNextLine;\n    // Seek to first word or non-whitespace character, depending on if\n    // noSymbol is true.\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n      test = function ( /** @type {string} */ch) {\n        return /\\s/.test(ch);\n      };\n    } else {\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n          if (!multiline) return null;\n          idx--;\n          wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n          break;\n        }\n      }\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n    }\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n    if (wordOnNextLine) {\n      end = wordOnNextLine.to;\n      endLineNumber = wordOnNextLine.line;\n      endLine = cm.getLine(endLineNumber);\n      if (!endLine && end == 0) end++;\n    } else {\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n    }\n    if (inclusive) {\n      // If present, include all whitespace after word.\n      // Otherwise, include all whitespace before word, except indentation.\n      var wordEnd = end;\n      var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n      if (!startsWithSpace) {\n        while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) {\n          end++;\n        }\n      }\n      if (wordEnd == end || startsWithSpace) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start && !startsWithSpace) {\n          start = wordStart;\n        }\n      }\n    }\n    return {\n      start: new Pos(startLineNumber, start),\n      end: new Pos(endLineNumber, end)\n    };\n  }\n\n  /**\n   * Depends on the following:\n   *\n   * - editor mode should be htmlmixedmode / xml\n   * - mode/xml/xml.js should be loaded\n   * - addon/fold/xml-fold.js should be loaded\n   *\n   * If any of the above requirements are not true, this function noops.\n   *\n   * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n   * The following caveats apply (based off cursory testing, I'm sure there\n   * are other discrepancies):\n   *\n   * - Does not work inside comments:\n   *   ```\n   *   <!-- <div>broken</div> -->\n   *   ```\n   * - Does not work when tags have different cases:\n   *   ```\n   *   <div>broken</DIV>\n   *   ```\n   * - Does not work when cursor is inside a broken tag:\n   *   ```\n   *   <div><brok><en></div>\n   *   ```\n   * @arg {CodeMirror} cm \n   * @arg {Pos} head \n   * @arg {boolean} [inclusive]\n   */\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n    if (inclusive) {\n      return {\n        start: tags.open.from,\n        end: tags.close.to\n      };\n    }\n    return {\n      start: tags.open.to,\n      end: tags.close.from\n    };\n  }\n\n  /** @arg {CodeMirror} cm @arg {Pos} oldCur @arg {Pos} newCur */\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  /** @arg {number} increment  @arg {{ forward?: any; selectedCharacter?: any; }} args */\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    // TODO: The original Vim implementation only operates on level 1 and 2.\n    // The current implementation doesn't check for code block level and\n    // therefore it operates on any levels.\n    method: {\n      init: function (state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0) return true;\n        }\n        return false;\n      }\n    }\n  };\n  /** @arg {CodeMirrorV} cm  @arg {number} repeat  @arg {boolean|undefined} forward  @arg {string} symb */\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n\n  /*\n    * Returns the boundaries of the next word. If the cursor in the middle of\n    * the word, then returns the boundaries of the current word, starting at\n    * the cursor. If the cursor is at the start/end of a word, and we are going\n    * forward/backward, respectively, find the boundaries of the next word.\n    *\n    * @arg {CodeMirror} cm CodeMirror object.\n    * @arg {Cursor} cur The cursor position.\n    * @arg {boolean} forward True to search forward. False to search\n    *     backward.\n    * @arg {boolean} bigWord True if punctuation count as part of the word.\n    *     False if only [a-zA-Z0-9] characters count as part of the word.\n    * @arg {boolean} emptyLineIsWord True if empty lines should be treated\n    *     as words.\n    * @return {Object{from:number, to:number, line: number}} The boundaries of\n    *     the word, or null if there are no more words.\n    */\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      // Find bounds of next word.\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            // Advance to end of word.\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              // We started at the end of a word. Find the next one.\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      // Advance to next/prev line.\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n\n  /**\n   * @arg {CodeMirror} cm CodeMirror object.\n   * @arg {Pos} cur The position to start from.\n   * @arg {number} repeat Number of words to move past.\n   * @arg {boolean} forward True to search forward. False to search\n   *     backward.\n   * @arg {boolean} wordEnd True to move to end of word. False to move to\n   *     beginning of word.\n   * @arg {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only alphabet characters count as part of the word.\n   * @return {Pos|undefined} The position the cursor should move to.\n   */\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    // For 'e', empty lines are not considered words, go figure.\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      // w\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return lastWord && new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return lastWord && new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      // ge\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return lastWord && new Pos(lastWord.line, lastWord.to);\n    } else {\n      // b\n      return lastWord && new Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {Pos} head \n   * @arg {MotionArgs} motionArgs \n   * @arg {vimState} vim \n   * @arg {boolean} keepHPos */\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, 'div').left;\n    }\n    return retval;\n  }\n\n  /** \n   * @arg {CodeMirror} cm \n   * @arg {number} repeat \n   * @arg {boolean} [forward]\n   * @arg {string} [character]\n   * @arg {Pos} [head]\n   */\n  function moveToCharacter(cm, repeat, forward, character, head) {\n    if (!character) return;\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return undefined;\n      }\n      start = idx;\n    }\n    if (idx != undefined) return new Pos(cm.getCursor().line, idx);\n  }\n\n  /** @arg {CodeMirrorV} cm @arg {number} repeat */\n  function moveToColumn(cm, repeat) {\n    // repeat is always >= 1, so repeat - 1 always corresponds\n    // to the column we want to go to.\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {vimState} vim \n   * @arg {string} markName \n   * @arg {Pos} pos */\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  /**\n   * @arg {number} start \n   * @arg {string | any[]} line \n   * @arg {any} character \n   * @arg {boolean} [forward] \n   * @arg {boolean} [includeChar] */\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    // Search for char in line.\n    // motion_options: {forward, includeChar}\n    // If includeChar = true, include it too.\n    // If forward = true, search forward, else search backwards.\n    // If char is not found on this line, do nothing\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n\n  /** @arg {CodeMirrorV} cm \n   * @arg {Pos} head \n   * @arg {number} repeat \n   * @arg {number} dir \n   * @arg {boolean} [inclusive] */\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    /** @arg {number} i */\n    function isEmpty(i) {\n      return !cm.getLine(i);\n    }\n    /** @arg {number} i @arg {number} dir @arg {boolean} [any] */\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return {\n        start: new Pos(i, 0),\n        end: head\n      };\n    }\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    // select boundary before paragraph for the last one\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  /**\n   * Based on {@link findSentence}. The internal functions have the same names,\n   * but their behaviour is different. findSentence() crosses line breaks and \n   * is used for jumping to sentence beginnings before or after the current cursor position, \n   * whereas getSentence() is for getting the beginning or end of the sentence \n   * at the current cursor position, either including (a) or excluding (i) whitespace.\n   * @arg {CodeMirror} cm\n   * @arg {Pos} cur\n   * @arg {number} repeat\n   * @arg {number} dir\n   * @arg {boolean} inclusive\n   */\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n      Takes an index object\n      {\n        line: the line string,\n        ln: line number,\n        pos: index in line,\n        dir: direction of traversal (-1 or 1)\n      }\n      and modifies the pos member to represent the\n      next valid position or sets the line to null if there are\n      no more valid positions.\n      */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      } else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n      Performs one iteration of traversal in forward direction\n      Returns an index object of the sentence end\n      */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos + 1\n            };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos + 1\n            };\n          }\n        }\n        nextChar(curr);\n      }\n      return {\n        ln: curr.ln,\n        pos: lastSentencePos + 1\n      };\n    }\n\n    /** \n     * Performs one iteration of traversal in reverse direction\n     * Returns an index object of the sentence start\n     * @arg {CodeMirror} cm  \n     * @arg {number} ln  \n     * @arg {number} pos  \n     * @arg {number} dir\n     */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      if (curr.line === \"\") {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      }\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return {\n              ln: curr.ln,\n              pos: lastSentencePos\n            };\n          } else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return {\n                ln: curr.ln,\n                pos: curr.pos + 1\n              };\n            } else {\n              return {\n                ln: curr.ln,\n                pos: lastSentencePos\n              };\n            }\n          }\n        }\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n      } else {\n        return {\n          ln: curr.ln,\n          pos: lastSentencePos\n        };\n      }\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n  function findSentence(cm, cur, repeat, dir) {\n    /*\n      Takes an index object\n      {\n        line: the line string,\n        ln: line number,\n        pos: index in line,\n        dir: direction of traversal (-1 or 1)\n      }\n      and modifies the line, ln, and pos members to represent the\n      next valid position or sets them to null if there are\n      no more valid positions.\n    */\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    /*\n      Performs one iteration of traversal in forward direction\n      Returns an index object of the new location\n      */\n    /** @arg {CodeMirror} cm @arg {number} ln  @arg {number} pos  @arg {number} dir */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the last non whitespace character on the last\n        valid line in the case that we reach the end of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n\n    /*\n      Performs one iteration of traversal in reverse direction\n      Returns an index object of the new location\n      */\n    /** @arg {CodeMirror} cm  @arg {number} ln  @arg {number} pos  @arg {number} dir */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n\n      /** @type {{ln: number, pos: number|null}} */\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the first non whitespace character on the last\n        valid line in the case that we reach the beginning of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  // TODO: perhaps this finagling of start and end positions belongs\n  // in codemirror/replaceRange?\n  /** @arg {CodeMirror} cm  @arg {Pos} head @arg {string | number} symb @arg {boolean} inclusive */\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    // Due to the behavior of scanForBracket, we need to add an offset if the\n    // cursor is on a matching open bracket.\n    var offset = curChar === openSym ? 1 : 0;\n    var startBracket = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    var endBracket = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    if (!startBracket || !endBracket) return null;\n    var start = startBracket.pos;\n    var end = endBracket.pos;\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  // Takes in a symbol and a cursor and tries to simulate text objects that\n  // have identical opening and closing symbols\n  // TODO support across multiple lines\n  /** @arg {CodeMirror} cm  @arg {Pos} head  @arg {string} symb @arg {boolean} inclusive */\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    // the decision tree is to always look backwards for the beginning first,\n    // but if the cursor is in front of the first instance of the symb,\n    // then move the cursor forward\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    }\n    // otherwise if the cursor is currently on the closing symbol\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n      var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n      var isStringStart = stringAfter && !stringBefore;\n      if (!isStringStart) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n    }\n\n    // if we're currently on the symbol, we've got a start\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      // go backwards to find the start\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    // look forwards for the end symbol\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    // nothing found\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    // include the symbols\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n\n  // Search functions\n  defineOption('pcre', true, 'boolean');\n  class SearchState {\n    getQuery() {\n      return vimGlobalState.query;\n    }\n    setQuery(query) {\n      vimGlobalState.query = query;\n    }\n    getOverlay() {\n      return this.searchOverlay;\n    }\n    setOverlay(overlay) {\n      this.searchOverlay = overlay;\n    }\n    isReversed() {\n      return vimGlobalState.isReversed;\n    }\n    setReversed(reversed) {\n      vimGlobalState.isReversed = reversed;\n    }\n    getScrollbarAnnotate() {\n      return this.annotate;\n    }\n    setScrollbarAnnotate(annotate) {\n      this.annotate = annotate;\n    }\n  } /** @arg {CodeMirrorV} cm */\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  /** @arg {string} argString */\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n\n  /** @arg {string} argString */\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n\n  /** @arg {string} argString  @arg {string} separator */\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    // in case of strings like foo/bar\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n\n  /** @arg {string} str  @arg {string} separator */\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n    return slashes;\n  }\n\n  // Translates a search string from ex (vim) syntax into javascript form.\n  /** @arg {string} str */\n  function translateRegex(str) {\n    // When these match, add a '\\' if unescaped or remove one if escaped.\n    var specials = '|(){';\n    // Remove, but never add, a '\\' for these.\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          // Treat the unescape list as special for removing, but not adding '\\'.\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          // Not passing this test means removing a '\\'.\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Translates the replace part of a search and replace from ex (vim) syntax into\n  // javascript form.  Similar to translateRegex, but additionally fixes back references\n  // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n  /** @type{Object<string, string>} */\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n  /** @arg {string} str */\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        // At any point in the loop, escapeNextChar is true if the previous\n        // character was a '\\' and was not escaped.\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Unescape \\ and / in the replace part, for PCRE mode.\n  /** @type{Record<string, string>} */\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t',\n    '\\\\&': '&'\n  };\n  /** @arg {string} str */\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      // Search for \\.\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        // Don't change anything\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n\n  /**\n   * Extract the regular expression from the query and return a Regexp object.\n   * Returns null if the query is blank.\n   * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n   * If smartCase is passed in, and the query contains upper case letters,\n   *   then ignoreCase is overridden, and the 'i' flag will not be set.\n   * If the query contains the /i in the flag part of the regular expression,\n   *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n   *   through to the Regex object.\n   * @arg {string|RegExp} query\n   * @arg {boolean} ignoreCase\n   * @arg {boolean} smartCase\n   */\n  function parseQuery(query, ignoreCase, smartCase) {\n    // First update the last search register\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    // Check if the query is already a regex.\n    if (query instanceof RegExp) {\n      return query;\n    }\n    // First try to extract regex + flags from the input. If no flags found,\n    // extract just the regex. IE does not accept flags directly defined in\n    // the regex string in the form /regex/flags\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      // Query looks like 'regexp'\n      regexPart = query;\n    } else {\n      // Query looks like 'regexp/...'\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'im' : 'm');\n    return regexp;\n  }\n\n  /**\n   * dom - Document Object Manipulator\n   * Usage:\n   *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n   * Examples:\n   *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n   *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n   * Not supported:\n   *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n   * @arg {string | HTMLElement } n\n   */\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n\n  /** @arg {CodeMirror} cm  @arg {any} template */\n  function showConfirm(cm, template) {\n    var pre = dom('div', {\n      $color: 'red',\n      $whiteSpace: 'pre',\n      class: 'cm-vim-message'\n    }, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  /** @arg {string} prefix  @arg {string} desc */\n  function makePrompt(prefix, desc) {\n    return dom('div', {\n      $display: 'flex'\n    }, dom('span', {\n      $fontFamily: 'monospace',\n      $whiteSpace: 'pre',\n      $flex: 1\n    }, prefix, dom('input', {\n      type: 'text',\n      autocorrect: 'off',\n      autocapitalize: 'off',\n      spellcheck: 'false',\n      $width: '100%'\n    })), desc && dom('span', {\n      $color: '#888'\n    }, desc));\n  }\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {{ onClose?: any; prefix: any; desc?: any; onKeyUp?: any; onKeyDown: any; value?: any; selectValueOnOpen?: boolean; }} options \n   */\n  function showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n      if (!options.value) options.value = '';\n      virtualPrompt = options;\n      return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value\n      });\n    } else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n\n  /** @arg {RegExp|unknown} r1  @arg {RegExp|unknown} r2 */\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  // Returns true if the query is valid.\n  /**\n   * @arg {CodeMirrorV} cm \n   * @arg {string | RegExp} rawQuery \n   * @arg {boolean | undefined} [ignoreCase] \n   * @arg {boolean | undefined} [smartCase]\n  */\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  /** @arg {RegExp} query */\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            // Matched empty string, skip to next.\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            // Backtrack 1 to match \\b\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  /** @arg {CodeMirrorV} cm  @arg {RegExp} query */\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      searchState.highlightTimeout = null;\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  /** @arg {CodeMirror} cm @arg {boolean} prev @arg {RegExp} query @arg {number | undefined} [repeat] */\n  function findNext(cm, prev, query, repeat) {\n    return cm.operation(function () {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        // @ts-ignore\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          // @ts-ignore\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            // @ts-ignore\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query,\n          // @ts-ignore\n          prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  /**\n   * Pretty much the same as `findNext`, except for the following differences:\n   *\n   * 1. Before starting the search, move to the previous search. This way if our cursor is\n   * already inside a match, we should return the current match.\n   * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n   * @arg {CodeMirror} cm\n   * @arg {boolean} prev\n   * @arg {any} query\n   * @arg {number | undefined} repeat\n   * @arg {vimState} vim\n   */\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    return cm.operation(function () {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      // Go back one result to ensure that if the cursor is currently a match, we keep it.\n      var found = cursor.find(!prev);\n\n      // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n      // @ts-ignore\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query,\n          // @ts-ignore\n          prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  /** @arg {CodeMirrorV} cm */\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n      clearTimeout(state.highlightTimeout);\n      state.highlightTimeout = null;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  /**\n   * Check if pos is in the specified range, INCLUSIVE.\n   * Range can be specified with 1 or 2 arguments.\n   * If the first range argument is an array, treat it as an array of line\n   * numbers. Match pos against any of the lines.\n   * If the first range argument is a number,\n   *   if there is only 1 range argument, check if pos has the same line\n   *       number\n   *   if there are 2 range arguments, then check if pos is in between the two\n   *       range arguments.\n   * @arg {number|Pos} pos\n   * @arg {number|number[]} start\n   * @arg {number} end\n   */\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      // Assume it is a cursor position. Get the line number.\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  /** @arg {CodeMirror} cm */\n  function getUserVisibleLines(cm) {\n    var scrollInfo = cm.getScrollInfo();\n    var occludeToleranceTop = 6;\n    var occludeToleranceBottom = 10;\n    var from = cm.coordsChar({\n      left: 0,\n      top: occludeToleranceTop + scrollInfo.top\n    }, 'local');\n    var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n    var to = cm.coordsChar({\n      left: 0,\n      top: bottomY\n    }, 'local');\n    return {\n      top: from.line,\n      bottom: to.line\n    };\n  }\n\n  /** @arg {CodeMirror} cm @arg {vimState} vim  @arg {string} markName */\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  /** @arg {CodeMirror} cm */\n  function getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n      return cm.getLastEditEnd();\n    }\n    // for old cm\n    var done = /**@type{any}*/cm.doc.history.done;\n    for (var i = done.length; i--;) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n  class ExCommandDispatcher {\n    constructor() {\n      /**@type {Record<string, any>} */\n      this.commandMap_;\n      this.buildCommandMap_();\n    }\n    processCommand(cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    }\n    _processCommand(cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      var inputStream = new CodeMirror.StringStream(input);\n      // update \": with the latest command whether valid or invalid\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e + \"\");\n        throw e;\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        // If only a line range is defined, move to the line.\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            // Handle Ex to Key mapping.\n            doKeyToKey(cm, command.toKeys, command);\n            return;\n          } else if (command.type == 'exToEx') {\n            // Handle Ex to Ex mapping.\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        // Possibly asynchronous commands (e.g. substitute, which might have a\n        // user confirmation), are responsible for calling the callback when\n        // done. All others have it taken care of for them here.\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e + \"\");\n        throw e;\n      }\n    }\n    parseInput_(cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      // Parse range.\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n      if (result.line == undefined) {\n        if (cm.state.vim.visualMode) {\n          result.selectionLine = getMarkPos(cm, cm.state.vim, '<')?.line;\n          result.selectionLineEnd = getMarkPos(cm, cm.state.vim, '>')?.line;\n        } else {\n          result.selectionLine = cm.getCursor().line;\n        }\n      } else {\n        result.selectionLine = result.line;\n        result.selectionLineEnd = result.lineEnd;\n      }\n\n      // Parse command name.\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n      return result;\n    }\n    parseLineSpec_(cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        // Absolute line number plus offset (N+M or N-M) is probably a typo,\n        // not something the user actually wanted. (NB: vim does allow this.)\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          // Offset is relative to current line if not otherwise specified.\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    }\n    parseLineSpecOffset_(inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    }\n    parseCommandArgs_(inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      // Parse command-line arguments\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    }\n    matchCommand_(commandName) {\n      // Return the command in the command map that matches the shortest\n      // prefix of the passed in command name. The match is guaranteed to be\n      // unambiguous if the defaultExCommandMap's shortNames are set up\n      // correctly. (see @code{defaultExCommandMap}).\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    }\n    buildCommandMap_() {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    }\n    /**@type {(lhs: string, rhs: string, ctx: string, noremap?: boolean) => void} */\n    map(lhs, rhs, ctx, noremap) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          // Ex to Ex mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          // Ex to key mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        // Key to key or ex mapping\n        var mapping = {\n          keys: lhs,\n          type: 'keyToKey',\n          toKeys: rhs,\n          noremap: !!noremap\n        };\n        if (ctx) {\n          mapping.context = ctx;\n        }\n        // @ts-ignore\n        defaultKeymap.unshift(mapping);\n      }\n    }\n    /**@type {(lhs: string, ctx: string) => boolean|void} */\n    unmap(lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        // Ex to Ex or Ex to key mapping\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        // Key to Ex or key to key mapping\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  /** @typedef { import(\"./types\").ExParams} ExParams */\n  var exCommands = {\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx, defaultOnly) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    imap: function (cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nmap: function (cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vmap: function (cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    omap: function (cm, params) {\n      this.map(cm, params, 'operatorPending');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    noremap: function (cm, params) {\n      this.map(cm, params, undefined, true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    inoremap: function (cm, params) {\n      this.map(cm, params, 'insert', true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nnoremap: function (cm, params) {\n      this.map(cm, params, 'normal', true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vnoremap: function (cm, params) {\n      this.map(cm, params, 'visual', true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    onoremap: function (cm, params) {\n      this.map(cm, params, 'operatorPending', true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params @arg {string} ctx*/\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    mapclear: function (cm, params) {\n      vimApi.mapclear();\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    imapclear: function (cm, params) {\n      vimApi.mapclear('insert');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nmapclear: function (cm, params) {\n      vimApi.mapclear('normal');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vmapclear: function (cm, params) {\n      vimApi.mapclear('visual');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    omapclear: function (cm, params) {\n      vimApi.mapclear('operatorPending');\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        keys: \"\",\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    set: function (cm, params) {\n      var setArgs = params.args;\n      // Options passed through to the setOption/getOption calls. May be passed in by the\n      // local/global versions of the set command\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr.shift() || \"\";\n      /**@type {string|boolean|undefined} */\n      var value = expr.length > 0 ? expr.join('=') : undefined;\n      var forceGet = false;\n      var forceToggle = false;\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        // If post-fixed with ?, then the set is actually a get.\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      } else if (optionName.charAt(optionName.length - 1) == '!') {\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceToggle = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        // To set boolean options to false, the option name is prefixed with\n        // 'no'.\n        optionName = optionName.substring(2);\n        value = false;\n      }\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean) {\n        if (forceToggle) {\n          value = !getOption(optionName, cm, setCfg);\n        } else if (value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n      }\n      // If no value is provided, then we assume this is a get.\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    setlocal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    setglobal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerNames = regArgs.join('');\n        for (var i = 0; i < registerNames.length; i++) {\n          var registerName = registerNames.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat('!')) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts || !args.eol()) {\n            return 'Invalid arguments';\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1;\n            var hex = opts[1].indexOf('x') != -1;\n            var octal = opts[1].indexOf('o') != -1;\n            if (Number(decimal) + Number(hex) + Number(octal) > 1) {\n              return 'Invalid arguments';\n            }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : undefined;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (numberRegex && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      /** @arg {string} a  @arg {string} b */\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var amatch = numberRegex && numberRegex.exec(a);\n        var bmatch = numberRegex && numberRegex.exec(b);\n        if (!amatch || !bmatch) {\n          return a < b ? -1 : 1;\n        }\n        var anum = parseInt((amatch[1] + amatch[2]).toLowerCase(), radix);\n        var bnum = parseInt((bmatch[1] + bmatch[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      /** @arg {string[]} a  @arg {string[]} b */\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      // @ts-ignore\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          // @ts-ignore\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vglobal: function (cm, params) {\n      // global inspects params.commandName\n      this.global(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    normal: function (cm, params) {\n      var argString = params.argString;\n      if (argString && argString[0] == '!') {\n        argString = argString.slice(1);\n        noremap = true;\n      }\n      argString = argString.trimStart();\n      if (!argString) {\n        showConfirm(cm, 'Argument is required.');\n        return;\n      }\n      var line = params.line;\n      if (typeof line == 'number') {\n        var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n        for (var i = line; i <= lineEnd; i++) {\n          cm.setCursor(i, 0);\n          doKeyToKey(cm, params.argString.trimStart());\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      } else {\n        doKeyToKey(cm, params.argString.trimStart());\n        if (cm.state.vim.insertMode) {\n          exitInsertMode(cm, true);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    global: function (cm, params) {\n      // a global command is of the form\n      // :[range]g/pattern/[cmd]\n      // argString holds the string /pattern/[cmd]\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      if (argString[0] === '!' && params.commandName[0] === 'g') {\n        inverted = true;\n        argString = argString.slice(1);\n      }\n      // range is specified here\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      // get the tokens from argString\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd = \"\";\n      if (tokens && tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise\n        // use the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      // now that we have the regexPart, search for regex matches in the\n      // specified range of lines\n      var query = getSearchState(cm).getQuery();\n      /**@type {(string|import(\"./types\").LineHandle)[]}*/\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLine(i);\n        var matched = query.test(line);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n        }\n      }\n      // if there is no [cmd], just display the list of matched lines\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var lineHandle = matchedLines[index++];\n          var lineNum = cm.getLineNumber(lineHandle);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        } else if (cm.releaseLineHandles) {\n          cm.releaseLineHandles();\n        }\n      };\n      nextCommand();\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart = '',\n        replacePart = '',\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens && tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        // either the argString is empty or its of the form ' hello/world'\n        // actually splitBySlash returns a list of tokens\n        // only if the string starts with a '/'\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n      // After the 3rd slash, we can have flags followed by a space followed\n      // by count.\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise use\n        // the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    startinsert: function (cm, params) {\n      doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    /** @arg {CodeMirrorV} cm */\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        // Saves to text area if no save command is defined and cm.save() is available.\n        cm.save();\n      }\n    },\n    /** @arg {CodeMirrorV} cm */\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    /** @arg {CodeMirrorV} cm */\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    delete: function (cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      operators.delete(cm, {\n        linewise: true\n      }, [{\n        anchor: new Pos(line, 0),\n        head: new Pos(lineEnd + 1, 0)\n      }]);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    join: function (cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      cm.setCursor(new Pos(line, 0));\n      actions.joinLines(cm, {\n        repeat: lineEnd - line\n      }, cm.state.vim);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n\n        // Record the streams position at the beginning of the loop for use\n        // in error messages.\n        var count = stream.pos;\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n        var sym = stream.next();\n        // Check if this symbol is part of a range\n        if (stream.match('-', true)) {\n          // This symbol is part of a range.\n\n          // The range must terminate at an alphabetic character.\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var startMark = sym;\n          var finishMark = stream.next();\n          // The range must terminate at an alphabetic character which\n          // shares the same case as the start of the range.\n          if (startMark && finishMark && isLowerCase(startMark) == isLowerCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            // Because marks are always ASCII values, and we have\n            // determined that they are the same case, we can use\n            // their char codes to iterate through the defined range.\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else if (sym) {\n          // This symbol is a valid mark, and is not part of a range.\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n  /**\n   * @arg {CodeMirrorV} cm CodeMirror instance we are in.\n   * @arg {boolean} confirm Whether to confirm each replace.\n   * @arg {boolean} global \n   * @arg {number} lineStart Line to start replacing from.\n   * @arg {number} lineEnd Line to stop replacing at.\n   * @arg {RegExp} query Query for performing matches with.\n   * @arg {string} replaceWith Text to replace matches with. May contain $1,\n   *     $2, etc for replacing captured groups using JavaScript replace.\n   * @arg {function} [callback] A callback for when the replace is done.\n   */\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    // Set up all the functions.\n    cm.state.vim.exMode = true;\n    var done = false;\n\n    /** @type {Pos}*/\n    var lastPos;\n    /** @type {number}*/\n    var modifiedLineNumber;\n    /** @type {boolean}*/\n    var joined;\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      // The below only loops to skip over multiple occurrences on the same\n      // line when 'global' is not true.\n      while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    /** @arg {(() => void) | undefined} [close] */\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    /** @arg {KeyboardEvent} e   @arg {any} _value   @arg {any} close */\n    function onPromptKeyDown(e, _value, close) {\n      // Swallow all keys.\n      CodeMirror.e_stop(e);\n      var keyName = vimKeyFromEvent(e);\n      switch (keyName) {\n        case 'y':\n          replace();\n          next();\n          break;\n        case 'n':\n          next();\n          break;\n        case 'a':\n          // replaceAll contains a call to close of its own. We don't want it\n          // to fire too early or multiple times.\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'l':\n          replace();\n        // fall through and exit.\n        case 'q':\n        case '<Esc>':\n        case '<C-c>':\n        case '<C-[>':\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n\n    // Actually do replace.\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n\n  /** @arg {CodeMirrorV} cm  @arg {boolean} [keepCursor] */\n  function exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      if (vim.insertEnd) vim.insertEnd.clear();\n      vim.insertEnd = undefined;\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      // Perform insert mode repeat for commands like 3,a and 3,o.\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n      // @ts-ignore\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    // update the \". register before exiting insert mode\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n\n  /** @arg {vimKey} command*/\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n\n  /** \n   * @arg {string} keys\n   * @arg {string} type   \n   * @arg {string} name\n   * @arg {any} args\n   * @arg {{ [x: string]: any; }} extra \n   **/\n  function mapCommand(keys, type, name, args, extra) {\n    /**@type{any} */\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) command[key] = extra[key];\n    _mapCommand(command);\n  }\n\n  // The timeout in milliseconds for the two-character ESC keymap should be\n  // adjusted according to your typing speed to prevent false positives.\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n  /**\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState} vim \n   * @arg {MacroModeState} macroModeState \n   * @arg {string} registerName\n   */\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      // Read-only register containing last Ex command.\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n      while (match = keyRe.exec(text)) {\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        key = match[0];\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n\n  /** @arg {MacroModeState} macroModeState @arg {any} key */\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  /** @arg {MacroModeState} macroModeState */\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  /** @arg {MacroModeState} macroModeState @arg {string} query */\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  /**\n   * Listens for changes made in insert mode.\n   * Should only be active in insert mode.\n   * @arg {CodeMirror} cm\n   * @arg {{ origin: string | undefined; text: any[]; next: any; }} changeObj\n   */\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      var vim = cm.state.vim;\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        // @ts-ignore\n        if (lastChange.ignoreCount > 1) {\n          // @ts-ignore\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              if (text.length > 1) {\n                var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                var cursor = cm.getCursor();\n                if (insertEnd && insertEnd.line == cursor.line) {\n                  var offset = insertEnd.ch - cursor.ch;\n                  if (offset > 0 && offset < text.length) {\n                    lastChange.changes.push([text, offset]);\n                    text = '';\n                  }\n                }\n              }\n              if (text) lastChange.changes.push(text);\n            }\n          }\n        }\n        // Change objects may be chained with next.\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  /**\n   * Listens for any kind of cursor activity on CodeMirror.\n   * @arg {CodeMirrorV} cm\n   */\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      // Tracking cursor activity in insert mode (for macro support).\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.maybeReset = true;\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(cm.getCursor(), {\n          insertLeft: true\n        });\n      }\n    } else if (!cm.curOp?.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  /** @arg {CodeMirrorV} cm  @arg {vimState} vim */\n  function handleExternalSelection(cm, vim) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    // Enter or exit visual mode to match mouse selection.\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n    if (vim.visualMode) {\n      // Bind CodeMirror selection model to vim selection model.\n      // Mouse selections are considered visual characterwise.\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode) {\n      // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  /**\n   * Wrapper for special keys pressed in insert mode\n   * @arg {string} keyName\n   */\n  function InsertModeKey(keyName, e) {\n    this.keyName = keyName;\n    this.key = e.key;\n    this.ctrlKey = e.ctrlKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    this.shiftKey = e.shiftKey;\n  }\n\n  /**\n   * Handles raw key down events from the text area.\n   * - Should only be active in insert mode.\n   * - For recording deletes in insert mode.\n   * @arg {KeyboardEvent} e\n   */\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n    if (!keyName) {\n      return;\n    }\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n  }\n\n  /**\n   * Repeats the last edit, which includes exactly 1 command and at most 1\n   * insert. Operator and motion commands are read from lastEditInputState,\n   * while action commands are read from lastEditActionCommand.\n   *\n   * If repeatForInsert is true, then the function was called by\n   * exitInsertMode to repeat the insert mode changes the user just made. The\n   * corresponding enterInsertMode call was made with a count.\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState} vim \n   * @arg {number} repeat  \n   * @arg {boolean} repeatForInsert\n   */\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var lastAction = vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (lastAction) {\n        commandDispatcher.processAction(cm, vim, lastAction);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    /** @arg {number} repeat */\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        // For some reason, repeat cw in desktop VIM does not repeat\n        // insert mode changes. Will conform to that behavior.\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    // @ts-ignore\n    vim.inputState = vim.lastEditInputState;\n    if (lastAction && lastAction.interlaceInsertRepeat) {\n      // o and O repeat have to be interlaced with insert repeats so that the\n      // insertions appear on separate lines instead of the last line.\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        // Hack to get the cursor to end up at the right place. If I is\n        // repeated in insert mode repeat, cursor will be 1 insert\n        // change set left of where it should be.\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      // Don't exit insert mode twice. If repeatForInsert is set, then we\n      // were called by an exitInsertMode call lower on the stack.\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  /**@arg {CodeMirrorV} cm, @arg {string} key */\n  function sendCmKey(cm, key) {\n    CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    });\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      // Set up block selection again for repeating the changes.\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          sendCmKey(cm, change.keyName);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n          cm.replaceRange(change[0], start, change[1] ? start : end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  // multiselect support\n  /** @arg {vimState} state */\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      if (key == \"insertEnd\") return;\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  /** @arg {CodeMirror} cm_  @arg {string} key @arg {string} origin */\n  function multiSelectHandleKey(cm_, key, origin) {\n    var vim = maybeInitVimState(cm_);\n    var cm = /**@type {CodeMirrorV}*/cm_;\n    /** @type {boolean | undefined} */\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.isInMultiSelectMode();\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n      // allow editor to exit multiselect\n      clearInputState(cm);\n      // @ts-ignore\n    } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      var changeQueueList = vim.inputState.changeQueueList || [];\n      cm.operation(function () {\n        if (cm.curOp) cm.curOp.isVimOp = true;\n        var index = 0;\n        cm.forEachSelection(function () {\n          cm.state.vim.inputState.changeQueue = changeQueueList[index];\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = vimApi.handleKey(cm, key, origin);\n          if (cm.virtualSelection) {\n            changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n            cm.state.vim = cloneVimState(old);\n          }\n          index++;\n        });\n        if (cm.curOp?.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n        cm.state.vim = vim;\n        vim.inputState.changeQueueList = changeQueueList;\n        vim.inputState.changeQueue = null;\n      }, true);\n    }\n    // some commands may bring visualMode and selection out of sync\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim);\n    }\n    return isHandled;\n  }\n  resetVimGlobalState();\n  return vimApi;\n}\nfunction indexFromPos(doc, pos) {\n  var ch = pos.ch;\n  var lineNumber = pos.line + 1;\n  if (lineNumber < 1) {\n    lineNumber = 1;\n    ch = 0;\n  }\n  if (lineNumber > doc.lines) {\n    lineNumber = doc.lines;\n    ch = Number.MAX_VALUE;\n  }\n  var line = doc.line(lineNumber);\n  return Math.min(line.from + Math.max(0, ch), line.to);\n}\nfunction posFromIndex(doc, offset) {\n  let line = doc.lineAt(offset);\n  return {\n    line: line.number - 1,\n    ch: offset - line.from\n  };\n}\nclass Pos {\n  constructor(line, ch) {\n    this.line = line;\n    this.ch = ch;\n  }\n}\nfunction on(emitter, type, f) {\n  if (emitter.addEventListener) {\n    emitter.addEventListener(type, f, false);\n  } else {\n    var map = emitter._handlers || (emitter._handlers = {});\n    map[type] = (map[type] || []).concat(f);\n  }\n}\nfunction off(emitter, type, f) {\n  if (emitter.removeEventListener) {\n    emitter.removeEventListener(type, f, false);\n  } else {\n    var map = emitter._handlers,\n      arr = map && map[type];\n    if (arr) {\n      var index = arr.indexOf(f);\n      if (index > -1) {\n        map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n      }\n    }\n  }\n}\nfunction signal(emitter, type, ...args) {\n  var _a;\n  var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];\n  if (!handlers) return;\n  for (var i = 0; i < handlers.length; ++i) {\n    handlers[i](...args);\n  }\n}\nfunction signalTo(handlers, ...args) {\n  if (!handlers) return;\n  for (var i = 0; i < handlers.length; ++i) {\n    handlers[i](...args);\n  }\n}\nlet wordChar;\ntry {\n  wordChar = /*@__PURE__*/new RegExp(\"[\\\\w\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {\n  wordChar = /[\\w]/;\n}\n// workaround for missing api for merging transactions\nfunction dispatchChange(cm, transaction) {\n  var view = cm.cm6;\n  if (view.state.readOnly) return;\n  var type = \"input.type.compose\";\n  if (cm.curOp) {\n    if (!cm.curOp.lastChange) type = \"input.type.compose.start\";\n  }\n  if (transaction.annotations) {\n    try {\n      transaction.annotations.some(function (note) {\n        if (note.value == \"input\") note.value = type;\n      });\n    } catch (e) {\n      console.error(e);\n    }\n  } else {\n    transaction.userEvent = type;\n  }\n  return view.dispatch(transaction);\n}\nfunction runHistoryCommand(cm, revert) {\n  var _a;\n  if (cm.curOp) {\n    cm.curOp.$changeStart = undefined;\n  }\n  (revert ? undo : redo)(cm.cm6);\n  let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;\n  // vim mode expects the changed text to be either selected or cursor placed at the start\n  if (changeStartIndex != null) {\n    cm.cm6.dispatch({\n      selection: {\n        anchor: changeStartIndex\n      }\n    });\n  }\n}\nvar keys = {};\n/*@__PURE__*/\n\"Left|Right|Up|Down|Backspace|Delete\".split(\"|\").forEach(key => {\n  keys[key] = cm => runScopeHandlers(cm.cm6, {\n    key: key\n  }, \"editor\");\n});\nclass CodeMirror {\n  constructor(cm6) {\n    this.state = {};\n    this.marks = Object.create(null);\n    this.$mid = 0; // marker id counter\n    this.options = {};\n    this._handlers = {};\n    this.$lastChangeEndOffset = 0;\n    this.virtualSelection = null;\n    this.cm6 = cm6;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n  }\n  // --------------------------\n  openDialog(template, callback, options) {\n    return openDialog(this, template, callback, options);\n  }\n  openNotification(template, options) {\n    return openNotification(this, template, options);\n  }\n  on(type, f) {\n    on(this, type, f);\n  }\n  off(type, f) {\n    off(this, type, f);\n  }\n  signal(type, e, handlers) {\n    signal(this, type, e, handlers);\n  }\n  indexFromPos(pos) {\n    return indexFromPos(this.cm6.state.doc, pos);\n  }\n  posFromIndex(offset) {\n    return posFromIndex(this.cm6.state.doc, offset);\n  }\n  foldCode(pos) {\n    let view = this.cm6;\n    let ranges = view.state.selection.ranges;\n    let doc = this.cm6.state.doc;\n    let index = indexFromPos(doc, pos);\n    let tmpRanges = EditorSelection.create([EditorSelection.range(index, index)], 0).ranges;\n    view.state.selection.ranges = tmpRanges;\n    foldCode(view);\n    view.state.selection.ranges = ranges;\n  }\n  firstLine() {\n    return 0;\n  }\n  lastLine() {\n    return this.cm6.state.doc.lines - 1;\n  }\n  lineCount() {\n    return this.cm6.state.doc.lines;\n  }\n  setCursor(line, ch) {\n    if (typeof line === 'object') {\n      ch = line.ch;\n      line = line.line;\n    }\n    var offset = indexFromPos(this.cm6.state.doc, {\n      line,\n      ch: ch || 0\n    });\n    this.cm6.dispatch({\n      selection: {\n        anchor: offset\n      }\n    }, {\n      scrollIntoView: !this.curOp\n    });\n    if (this.curOp && !this.curOp.isVimOp) this.onBeforeEndOperation();\n  }\n  getCursor(p) {\n    var sel = this.cm6.state.selection.main;\n    var offset = p == \"head\" || !p ? sel.head : p == \"anchor\" ? sel.anchor : p == \"start\" ? sel.from : p == \"end\" ? sel.to : null;\n    if (offset == null) throw new Error(\"Invalid cursor type\");\n    return this.posFromIndex(offset);\n  }\n  listSelections() {\n    var doc = this.cm6.state.doc;\n    return this.cm6.state.selection.ranges.map(r => {\n      return {\n        anchor: posFromIndex(doc, r.anchor),\n        head: posFromIndex(doc, r.head)\n      };\n    });\n  }\n  setSelections(p, primIndex) {\n    var doc = this.cm6.state.doc;\n    var ranges = p.map(x => {\n      var head = indexFromPos(doc, x.head);\n      var anchor = indexFromPos(doc, x.anchor);\n      // workaround for codemirror bug, see https://github.com/replit/codemirror-vim/issues/169\n      if (head == anchor) return EditorSelection.cursor(head, 1);\n      return EditorSelection.range(anchor, head);\n    });\n    this.cm6.dispatch({\n      selection: EditorSelection.create(ranges, primIndex)\n    });\n  }\n  setSelection(anchor, head, options) {\n    this.setSelections([{\n      anchor,\n      head\n    }], 0);\n    if (options && options.origin == '*mouse') {\n      this.onBeforeEndOperation();\n    }\n  }\n  getLine(row) {\n    var doc = this.cm6.state.doc;\n    if (row < 0 || row >= doc.lines) return \"\";\n    return this.cm6.state.doc.line(row + 1).text;\n  }\n  getLineHandle(row) {\n    if (!this.$lineHandleChanges) this.$lineHandleChanges = [];\n    return {\n      row: row,\n      index: this.indexFromPos(new Pos(row, 0))\n    };\n  }\n  getLineNumber(handle) {\n    var updates = this.$lineHandleChanges;\n    if (!updates) return null;\n    var offset = handle.index;\n    for (var i = 0; i < updates.length; i++) {\n      offset = updates[i].changes.mapPos(offset, 1, MapMode.TrackAfter);\n      if (offset == null) return null;\n    }\n    var pos = this.posFromIndex(offset);\n    return pos.ch == 0 ? pos.line : null;\n  }\n  releaseLineHandles() {\n    this.$lineHandleChanges = undefined;\n  }\n  getRange(s, e) {\n    var doc = this.cm6.state.doc;\n    return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));\n  }\n  replaceRange(text, s, e, source) {\n    if (!e) e = s;\n    var doc = this.cm6.state.doc;\n    var from = indexFromPos(doc, s);\n    var to = indexFromPos(doc, e);\n    dispatchChange(this, {\n      changes: {\n        from,\n        to,\n        insert: text\n      }\n    });\n  }\n  replaceSelection(text) {\n    dispatchChange(this, this.cm6.state.replaceSelection(text));\n  }\n  replaceSelections(replacements) {\n    var ranges = this.cm6.state.selection.ranges;\n    var changes = ranges.map((r, i) => {\n      return {\n        from: r.from,\n        to: r.to,\n        insert: replacements[i] || \"\"\n      };\n    });\n    dispatchChange(this, {\n      changes\n    });\n  }\n  getSelection() {\n    return this.getSelections().join(\"\\n\");\n  }\n  getSelections() {\n    var cm = this.cm6;\n    return cm.state.selection.ranges.map(r => cm.state.sliceDoc(r.from, r.to));\n  }\n  somethingSelected() {\n    return this.cm6.state.selection.ranges.some(r => !r.empty);\n  }\n  getInputField() {\n    return this.cm6.contentDOM;\n  }\n  clipPos(p) {\n    var doc = this.cm6.state.doc;\n    var ch = p.ch;\n    var lineNumber = p.line + 1;\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      ch = 0;\n    }\n    if (lineNumber > doc.lines) {\n      lineNumber = doc.lines;\n      ch = Number.MAX_VALUE;\n    }\n    var line = doc.line(lineNumber);\n    ch = Math.min(Math.max(0, ch), line.to - line.from);\n    return new Pos(lineNumber - 1, ch);\n  }\n  getValue() {\n    return this.cm6.state.doc.toString();\n  }\n  setValue(text) {\n    var cm = this.cm6;\n    return cm.dispatch({\n      changes: {\n        from: 0,\n        to: cm.state.doc.length,\n        insert: text\n      },\n      selection: EditorSelection.range(0, 0)\n    });\n  }\n  focus() {\n    return this.cm6.focus();\n  }\n  blur() {\n    return this.cm6.contentDOM.blur();\n  }\n  defaultTextHeight() {\n    return this.cm6.defaultLineHeight;\n  }\n  findMatchingBracket(pos, _options) {\n    var state = this.cm6.state;\n    var offset = indexFromPos(state.doc, pos);\n    var m = matchBrackets(state, offset + 1, -1);\n    if (m && m.end) {\n      return {\n        to: posFromIndex(state.doc, m.end.from)\n      };\n    }\n    m = matchBrackets(state, offset, 1);\n    if (m && m.end) {\n      return {\n        to: posFromIndex(state.doc, m.end.from)\n      };\n    }\n    return {\n      to: undefined\n    };\n  }\n  scanForBracket(pos, dir, style, config) {\n    return scanForBracket(this, pos, dir, style, config);\n  }\n  indentLine(line, more) {\n    // todo how to indent only one line instead of selection\n    if (more) this.indentMore();else this.indentLess();\n  }\n  indentMore() {\n    indentMore(this.cm6);\n  }\n  indentLess() {\n    indentLess(this.cm6);\n  }\n  execCommand(name) {\n    if (name == \"indentAuto\") CodeMirror.commands.indentAuto(this);else if (name == \"goLineLeft\") cursorLineBoundaryBackward(this.cm6);else if (name == \"goLineRight\") {\n      cursorLineBoundaryForward(this.cm6);\n      let state = this.cm6.state;\n      let cur = state.selection.main.head;\n      if (cur < state.doc.length && state.sliceDoc(cur, cur + 1) !== \"\\n\") {\n        cursorCharBackward(this.cm6);\n      }\n    } else console.log(name + \" is not implemented\");\n  }\n  setBookmark(cursor, options) {\n    var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;\n    var offset = this.indexFromPos(cursor);\n    var bm = new Marker(this, offset, assoc);\n    return bm;\n  }\n  addOverlay({\n    query\n  }) {\n    let cm6Query = new SearchQuery({\n      regexp: true,\n      search: query.source,\n      caseSensitive: !/i/.test(query.flags)\n    });\n    if (cm6Query.valid) {\n      cm6Query.forVim = true;\n      this.cm6Query = cm6Query;\n      let effect = setSearchQuery.of(cm6Query);\n      this.cm6.dispatch({\n        effects: effect\n      });\n      return cm6Query;\n    }\n  }\n  removeOverlay(overlay) {\n    if (!this.cm6Query) return;\n    this.cm6Query.forVim = false;\n    let effect = setSearchQuery.of(this.cm6Query);\n    this.cm6.dispatch({\n      effects: effect\n    });\n  }\n  getSearchCursor(query, pos) {\n    var cm = this;\n    var last = null;\n    var lastCM5Result = null;\n    if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n    var firstOffset = indexFromPos(cm.cm6.state.doc, pos);\n    var source = query.source.replace(/(\\\\.|{(?:\\d+(?:,\\d*)?|,\\d+)})|[{}]/g, function (a, b) {\n      if (!b) return \"\\\\\" + a;\n      return b;\n    });\n    function rCursor(doc, from = 0, to = doc.length) {\n      return new RegExpCursor(doc, source, {\n        ignoreCase: query.ignoreCase\n      }, from, to);\n    }\n    function nextMatch(from) {\n      var doc = cm.cm6.state.doc;\n      if (from > doc.length) return null;\n      let res = rCursor(doc, from).next();\n      return res.done ? null : res.value;\n    }\n    var ChunkSize = 10000;\n    function prevMatchInRange(from, to) {\n      var doc = cm.cm6.state.doc;\n      for (let size = 1;; size++) {\n        let start = Math.max(from, to - size * ChunkSize);\n        let cursor = rCursor(doc, start, to),\n          range = null;\n        while (!cursor.next().done) range = cursor.value;\n        if (range && (start == from || range.from > start + 10)) return range;\n        if (start == from) return null;\n      }\n    }\n    return {\n      findNext: function () {\n        return this.find(false);\n      },\n      findPrevious: function () {\n        return this.find(true);\n      },\n      find: function (back) {\n        var doc = cm.cm6.state.doc;\n        if (back) {\n          let endAt = last ? last.from == last.to ? last.to - 1 : last.from : firstOffset;\n          last = prevMatchInRange(0, endAt);\n        } else {\n          let startFrom = last ? last.from == last.to ? last.to + 1 : last.to : firstOffset;\n          last = nextMatch(startFrom);\n        }\n        lastCM5Result = last && {\n          from: posFromIndex(doc, last.from),\n          to: posFromIndex(doc, last.to),\n          match: last.match\n        };\n        return last && last.match;\n      },\n      from: function () {\n        return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from;\n      },\n      to: function () {\n        return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to;\n      },\n      replace: function (text) {\n        if (last) {\n          dispatchChange(cm, {\n            changes: {\n              from: last.from,\n              to: last.to,\n              insert: text\n            }\n          });\n          last.to = last.from + text.length;\n          if (lastCM5Result) {\n            lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);\n          }\n        }\n      }\n    };\n  }\n  findPosV(start, amount, unit, goalColumn) {\n    let {\n      cm6\n    } = this;\n    const doc = cm6.state.doc;\n    let pixels = unit == 'page' ? cm6.dom.clientHeight : 0;\n    const startOffset = indexFromPos(doc, start);\n    let range = EditorSelection.cursor(startOffset, 1, undefined, goalColumn);\n    let count = Math.round(Math.abs(amount));\n    for (let i = 0; i < count; i++) {\n      if (unit == 'page') {\n        range = cm6.moveVertically(range, amount > 0, pixels);\n      } else if (unit == 'line') {\n        range = cm6.moveVertically(range, amount > 0);\n      }\n    }\n    let pos = posFromIndex(doc, range.head);\n    // set hitside to true if there was no place to move and cursor was clipped to the edge\n    // of document. Needed for gj/gk\n    if (amount < 0 && range.head == 0 && goalColumn != 0 && start.line == 0 && start.ch != 0 || amount > 0 && range.head == doc.length && pos.ch != goalColumn && start.line == pos.line) {\n      pos.hitSide = true;\n    }\n    return pos;\n  }\n  charCoords(pos, mode) {\n    var rect = this.cm6.contentDOM.getBoundingClientRect();\n    var offset = indexFromPos(this.cm6.state.doc, pos);\n    var coords = this.cm6.coordsAtPos(offset);\n    var d = -rect.top;\n    return {\n      left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left,\n      top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d,\n      bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d\n    };\n  }\n  coordsChar(coords, mode) {\n    var rect = this.cm6.contentDOM.getBoundingClientRect();\n    var offset = this.cm6.posAtCoords({\n      x: coords.left + rect.left,\n      y: coords.top + rect.top\n    }) || 0;\n    return posFromIndex(this.cm6.state.doc, offset);\n  }\n  getScrollInfo() {\n    var scroller = this.cm6.scrollDOM;\n    return {\n      left: scroller.scrollLeft,\n      top: scroller.scrollTop,\n      height: scroller.scrollHeight,\n      width: scroller.scrollWidth,\n      clientHeight: scroller.clientHeight,\n      clientWidth: scroller.clientWidth\n    };\n  }\n  scrollTo(x, y) {\n    if (x != null) this.cm6.scrollDOM.scrollLeft = x;\n    if (y != null) this.cm6.scrollDOM.scrollTop = y;\n  }\n  scrollIntoView(pos, margin) {\n    if (pos) {\n      var offset = this.indexFromPos(pos);\n      this.cm6.dispatch({\n        effects: EditorView.scrollIntoView(offset)\n      });\n    } else {\n      this.cm6.dispatch({\n        scrollIntoView: true,\n        userEvent: \"scroll\"\n      });\n    }\n  }\n  getWrapperElement() {\n    return this.cm6.dom;\n  }\n  // for tests\n  getMode() {\n    return {\n      name: this.getOption(\"mode\")\n    };\n  }\n  setSize(w, h) {\n    this.cm6.dom.style.width = w + 4 + \"px\";\n    this.cm6.dom.style.height = h + \"px\";\n    this.refresh();\n  }\n  refresh() {\n    this.cm6.measure();\n  }\n  // event listeners\n  destroy() {\n    this.removeOverlay();\n  }\n  getLastEditEnd() {\n    return this.posFromIndex(this.$lastChangeEndOffset);\n  }\n  onChange(update) {\n    if (this.$lineHandleChanges) {\n      this.$lineHandleChanges.push(update);\n    }\n    for (let i in this.marks) {\n      let m = this.marks[i];\n      m.update(update.changes);\n    }\n    if (this.virtualSelection) {\n      this.virtualSelection.ranges = this.virtualSelection.ranges.map(range => range.map(update.changes));\n    }\n    var curOp = this.curOp = this.curOp || {};\n    update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n      if (curOp.$changeStart == null || curOp.$changeStart > fromB) curOp.$changeStart = fromB;\n      this.$lastChangeEndOffset = toB;\n      var change = {\n        text: text.toJSON()\n      };\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n    }, true);\n    if (!curOp.changeHandlers) curOp.changeHandlers = this._handlers[\"change\"] && this._handlers[\"change\"].slice();\n  }\n  onSelectionChange() {\n    var curOp = this.curOp = this.curOp || {};\n    if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._handlers[\"cursorActivity\"] && this._handlers[\"cursorActivity\"].slice();\n    this.curOp.cursorActivity = true;\n  }\n  operation(fn, force) {\n    if (!this.curOp) this.curOp = {\n      $d: 0\n    };\n    this.curOp.$d++;\n    try {\n      var result = fn();\n    } finally {\n      if (this.curOp) {\n        this.curOp.$d--;\n        if (!this.curOp.$d) this.onBeforeEndOperation();\n      }\n    }\n    return result;\n  }\n  onBeforeEndOperation() {\n    var op = this.curOp;\n    var scrollIntoView = false;\n    if (op) {\n      if (op.change) {\n        signalTo(op.changeHandlers, this, op.change);\n      }\n      if (op && op.cursorActivity) {\n        signalTo(op.cursorActivityHandlers, this, null);\n        if (op.isVimOp) scrollIntoView = true;\n      }\n      this.curOp = null;\n    }\n    if (scrollIntoView) this.scrollIntoView();\n  }\n  moveH(increment, unit) {\n    if (unit == 'char') {\n      // todo\n      var cur = this.getCursor();\n      this.setCursor(cur.line, cur.ch + increment);\n    }\n  }\n  setOption(name, val) {\n    switch (name) {\n      case \"keyMap\":\n        this.state.keyMap = val;\n        break;\n      case \"textwidth\":\n        this.state.textwidth = val;\n        break;\n    }\n  }\n  getOption(name) {\n    switch (name) {\n      case \"firstLineNumber\":\n        return 1;\n      case \"tabSize\":\n        return this.cm6.state.tabSize || 4;\n      case \"readOnly\":\n        return this.cm6.state.readOnly;\n      case \"indentWithTabs\":\n        return this.cm6.state.facet(indentUnit) == \"\\t\";\n      // TODO\n      case \"indentUnit\":\n        return this.cm6.state.facet(indentUnit).length || 2;\n      case \"textwidth\":\n        return this.state.textwidth;\n      // for tests\n      case \"keyMap\":\n        return this.state.keyMap || \"vim\";\n    }\n  }\n  toggleOverwrite(on) {\n    this.state.overwrite = on;\n  }\n  getTokenTypeAt(pos) {\n    var _a;\n    // only comment|string are needed\n    var offset = this.indexFromPos(pos);\n    var tree = ensureSyntaxTree(this.cm6.state, offset);\n    var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);\n    var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || \"\";\n    if (/comment/i.test(type)) return \"comment\";\n    if (/string/i.test(type)) return \"string\";\n    return \"\";\n  }\n  overWriteSelection(text) {\n    var doc = this.cm6.state.doc;\n    var sel = this.cm6.state.selection;\n    var ranges = sel.ranges.map(x => {\n      if (x.empty) {\n        var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : \"\";\n        if (ch && !/\\n/.test(ch)) return EditorSelection.range(x.from, x.to + 1);\n      }\n      return x;\n    });\n    this.cm6.dispatch({\n      selection: EditorSelection.create(ranges, sel.mainIndex)\n    });\n    this.replaceSelection(text);\n  }\n  /*** multiselect ****/\n  isInMultiSelectMode() {\n    return this.cm6.state.selection.ranges.length > 1;\n  }\n  virtualSelectionMode() {\n    return !!this.virtualSelection;\n  }\n  forEachSelection(command) {\n    var selection = this.cm6.state.selection;\n    this.virtualSelection = EditorSelection.create(selection.ranges, selection.mainIndex);\n    for (var i = 0; i < this.virtualSelection.ranges.length; i++) {\n      var range = this.virtualSelection.ranges[i];\n      if (!range) continue;\n      this.cm6.dispatch({\n        selection: EditorSelection.create([range])\n      });\n      command();\n      this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];\n    }\n    this.cm6.dispatch({\n      selection: this.virtualSelection\n    });\n    this.virtualSelection = null;\n  }\n  hardWrap(options) {\n    return hardWrap(this, options);\n  }\n}\nCodeMirror.isMac = typeof navigator != \"undefined\" && /*@__PURE__*/ /Mac/.test(navigator.platform);\n// --------------------------\nCodeMirror.Pos = Pos;\nCodeMirror.StringStream = StringStream;\nCodeMirror.commands = {\n  cursorCharLeft: function (cm) {\n    cursorCharLeft(cm.cm6);\n  },\n  redo: function (cm) {\n    runHistoryCommand(cm, false);\n  },\n  undo: function (cm) {\n    runHistoryCommand(cm, true);\n  },\n  newlineAndIndent: function (cm) {\n    insertNewlineAndIndent({\n      state: cm.cm6.state,\n      dispatch: tr => {\n        return dispatchChange(cm, tr);\n      }\n    });\n  },\n  indentAuto: function (cm) {\n    indentSelection(cm.cm6);\n  },\n  newlineAndIndentContinueComment: undefined,\n  save: undefined\n};\nCodeMirror.isWordChar = function (ch) {\n  return wordChar.test(ch);\n};\nCodeMirror.keys = keys;\nCodeMirror.addClass = function (el, str) {};\nCodeMirror.rmClass = function (el, str) {};\nCodeMirror.e_preventDefault = function (e) {\n  e.preventDefault();\n};\nCodeMirror.e_stop = function (e) {\n  var _a, _b;\n  (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);\n  (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n  var result = CodeMirror.keys[key];\n  if (result) handle(result);\n};\nCodeMirror.on = on;\nCodeMirror.off = off;\nCodeMirror.signal = signal;\nCodeMirror.findMatchingTag = findMatchingTag;\nCodeMirror.findEnclosingTag = findEnclosingTag;\nCodeMirror.keyName = undefined;\n/************* dialog *************/\nfunction dialogDiv(cm, template, bottom) {\n  var dialog = document.createElement(\"div\");\n  dialog.appendChild(template);\n  return dialog;\n}\nfunction closeNotification(cm, newVal) {\n  if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n  cm.state.currentNotificationClose = newVal;\n}\nfunction openNotification(cm, template, options) {\n  closeNotification(cm, close);\n  var dialog = dialogDiv(cm, template, options && options.bottom);\n  var closed = false;\n  var doneTimer;\n  var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n  function close() {\n    if (closed) return;\n    closed = true;\n    clearTimeout(doneTimer);\n    dialog.remove();\n    hideDialog(cm, dialog);\n  }\n  dialog.onclick = function (e) {\n    e.preventDefault();\n    close();\n  };\n  showDialog(cm, dialog);\n  if (duration) doneTimer = setTimeout(close, duration);\n  return close;\n}\nfunction showDialog(cm, dialog) {\n  var oldDialog = cm.state.dialog;\n  cm.state.dialog = dialog;\n  if (dialog && oldDialog !== dialog) {\n    if (oldDialog && oldDialog.contains(document.activeElement)) cm.focus();\n    if (oldDialog && oldDialog.parentElement) {\n      oldDialog.parentElement.replaceChild(dialog, oldDialog);\n    } else if (oldDialog) {\n      oldDialog.remove();\n    }\n    CodeMirror.signal(cm, \"dialog\");\n  }\n}\nfunction hideDialog(cm, dialog) {\n  if (cm.state.dialog == dialog) {\n    cm.state.dialog = null;\n    CodeMirror.signal(cm, \"dialog\");\n  }\n}\nfunction openDialog(me, template, callback, options) {\n  if (!options) options = {};\n  closeNotification(me, undefined);\n  var dialog = dialogDiv(me, template, options.bottom);\n  var closed = false;\n  showDialog(me, dialog);\n  function close(newVal) {\n    if (typeof newVal == 'string') {\n      inp.value = newVal;\n    } else {\n      if (closed) return;\n      closed = true;\n      hideDialog(me, dialog);\n      if (!me.state.dialog) me.focus();\n      if (options.onClose) options.onClose(dialog);\n    }\n  }\n  var inp = dialog.getElementsByTagName(\"input\")[0];\n  if (inp) {\n    if (options.value) {\n      inp.value = options.value;\n      if (options.selectValueOnOpen !== false) inp.select();\n    }\n    if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n      options.onInput(e, inp.value, close);\n    });\n    if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n      options.onKeyUp(e, inp.value, close);\n    });\n    CodeMirror.on(inp, \"keydown\", function (e) {\n      if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n        return;\n      }\n      if (e.keyCode == 13) callback(inp.value);\n      if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n        inp.blur();\n        CodeMirror.e_stop(e);\n        close();\n      }\n    });\n    if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", function () {\n      setTimeout(function () {\n        if (document.activeElement === inp) return;\n        close();\n      });\n    });\n    inp.focus();\n  }\n  return close;\n}\nvar matching = {\n  \"(\": \")>\",\n  \")\": \"(<\",\n  \"[\": \"]>\",\n  \"]\": \"[<\",\n  \"{\": \"}>\",\n  \"}\": \"{<\",\n  \"<\": \">>\",\n  \">\": \"<<\"\n};\nfunction bracketRegex(config) {\n  return config && config.bracketRegex || /[(){}[\\]]/;\n}\nfunction scanForBracket(cm, where, dir, style, config) {\n  var maxScanLen = config && config.maxScanLineLength || 10000;\n  var maxScanLines = config && config.maxScanLines || 1000;\n  var stack = [];\n  var re = bracketRegex(config);\n  var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n  for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n    var line = cm.getLine(lineNo);\n    if (!line) continue;\n    var pos = dir > 0 ? 0 : line.length - 1,\n      end = dir > 0 ? line.length : -1;\n    if (line.length > maxScanLen) continue;\n    if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n    for (; pos != end; pos += dir) {\n      var ch = line.charAt(pos);\n      if (re.test(ch) /*&& (style === undefined ||\n                          (cm.getTokenTypeAt(new Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))*/) {\n        var match = matching[ch];\n        if (match && match.charAt(1) == \">\" == dir > 0) stack.push(ch);else if (!stack.length) return {\n          pos: new Pos(lineNo, pos),\n          ch: ch\n        };else stack.pop();\n      }\n    }\n  }\n  return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n}\nfunction findMatchingTag(cm, pos) {}\nfunction findEnclosingTag(cm, pos) {\n  var _a, _b;\n  var state = cm.cm6.state;\n  var offset = cm.indexFromPos(pos);\n  if (offset < state.doc.length) {\n    var text = state.sliceDoc(offset, offset + 1);\n    if (text == \"<\") offset++;\n  }\n  var tree = ensureSyntaxTree(state, offset);\n  var node = (tree === null || tree === void 0 ? void 0 : tree.resolve(offset)) || null;\n  while (node) {\n    if (((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) == 'OpenTag' && ((_b = node.lastChild) === null || _b === void 0 ? void 0 : _b.type.name) == 'CloseTag') {\n      return {\n        open: convertRange(state.doc, node.firstChild),\n        close: convertRange(state.doc, node.lastChild)\n      };\n    }\n    node = node.parent;\n  }\n}\nfunction convertRange(doc, cm6Range) {\n  return {\n    from: posFromIndex(doc, cm6Range.from),\n    to: posFromIndex(doc, cm6Range.to)\n  };\n}\nclass Marker {\n  constructor(cm, offset, assoc) {\n    this.cm = cm;\n    this.id = cm.$mid++;\n    this.offset = offset;\n    this.assoc = assoc;\n    cm.marks[this.id] = this;\n  }\n  clear() {\n    delete this.cm.marks[this.id];\n  }\n  find() {\n    if (this.offset == null) return null;\n    return this.cm.posFromIndex(this.offset);\n  }\n  update(change) {\n    if (this.offset != null) this.offset = change.mapPos(this.offset, this.assoc, MapMode.TrackDel);\n  }\n}\nfunction hardWrap(cm, options) {\n  var _a;\n  var max = options.column || cm.getOption('textwidth') || 80;\n  var allowMerge = options.allowMerge != false;\n  var row = Math.min(options.from, options.to);\n  var endRow = Math.max(options.from, options.to);\n  while (row <= endRow) {\n    var line = cm.getLine(row);\n    if (line.length > max) {\n      var space = findSpace(line, max, 5);\n      if (space) {\n        var indentation = (_a = /^\\s*/.exec(line)) === null || _a === void 0 ? void 0 : _a[0];\n        cm.replaceRange(\"\\n\" + indentation, new Pos(row, space.start), new Pos(row, space.end));\n      }\n      endRow++;\n    } else if (allowMerge && /\\S/.test(line) && row != endRow) {\n      var nextLine = cm.getLine(row + 1);\n      if (nextLine && /\\S/.test(nextLine)) {\n        var trimmedLine = line.replace(/\\s+$/, \"\");\n        var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n        var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n        var space = findSpace(mergedLine, max, 5);\n        if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n          cm.replaceRange(\" \", new Pos(row, trimmedLine.length), new Pos(row + 1, nextLine.length - trimmedNextLine.length));\n          row--;\n          endRow--;\n        } else if (trimmedLine.length < line.length) {\n          cm.replaceRange(\"\", new Pos(row, trimmedLine.length), new Pos(row, line.length));\n        }\n      }\n    }\n    row++;\n  }\n  return row;\n  function findSpace(line, max, min) {\n    if (line.length < max) return;\n    var before = line.slice(0, max);\n    var after = line.slice(max);\n    var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n    var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n    var start = 0;\n    var end = 0;\n    if (spaceBefore && !spaceBefore[2]) {\n      start = max - spaceBefore[1].length;\n      end = max;\n    }\n    if (spaceAfter && !spaceAfter[2]) {\n      if (!start) start = max;\n      end = max + spaceAfter[1].length;\n    }\n    if (start) {\n      return {\n        start: start,\n        end: end\n      };\n    }\n    if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n      return {\n        start: spaceBefore.index,\n        end: spaceBefore.index + spaceBefore[2].length\n      };\n    }\n    if (spaceAfter && spaceAfter[2]) {\n      start = max + spaceAfter[2].length;\n      return {\n        start: start,\n        end: start + spaceAfter[3].length\n      };\n    }\n  }\n}\n\n// backwards compatibility for old versions not supporting getDrawSelectionConfig\nlet getDrawSelectionConfig = View.getDrawSelectionConfig || /*@__PURE__*/function () {\n  let defaultConfig = {\n    cursorBlinkRate: 1200\n  };\n  return function () {\n    return defaultConfig;\n  };\n}();\nclass Piece {\n  constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {\n    this.left = left;\n    this.top = top;\n    this.height = height;\n    this.fontFamily = fontFamily;\n    this.fontSize = fontSize;\n    this.fontWeight = fontWeight;\n    this.color = color;\n    this.className = className;\n    this.letter = letter;\n    this.partial = partial;\n  }\n  draw() {\n    let elt = document.createElement(\"div\");\n    elt.className = this.className;\n    this.adjust(elt);\n    return elt;\n  }\n  adjust(elt) {\n    elt.style.left = this.left + \"px\";\n    elt.style.top = this.top + \"px\";\n    elt.style.height = this.height + \"px\";\n    elt.style.lineHeight = this.height + \"px\";\n    elt.style.fontFamily = this.fontFamily;\n    elt.style.fontSize = this.fontSize;\n    elt.style.fontWeight = this.fontWeight;\n    elt.style.color = this.partial ? \"transparent\" : this.color;\n    elt.className = this.className;\n    elt.textContent = this.letter;\n  }\n  eq(p) {\n    return this.left == p.left && this.top == p.top && this.height == p.height && this.fontFamily == p.fontFamily && this.fontSize == p.fontSize && this.fontWeight == p.fontWeight && this.color == p.color && this.className == p.className && this.letter == p.letter;\n  }\n}\nclass BlockCursorPlugin {\n  constructor(view, cm) {\n    this.view = view;\n    this.rangePieces = [];\n    this.cursors = [];\n    this.cm = cm;\n    this.measureReq = {\n      read: this.readPos.bind(this),\n      write: this.drawSel.bind(this)\n    };\n    this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.cursorLayer.className = \"cm-cursorLayer cm-vimCursorLayer\";\n    this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n    view.requestMeasure(this.measureReq);\n    this.setBlinkRate();\n  }\n  setBlinkRate() {\n    let config = getDrawSelectionConfig(this.cm.cm6.state);\n    let blinkRate = config.cursorBlinkRate;\n    this.cursorLayer.style.animationDuration = blinkRate + \"ms\";\n  }\n  update(update) {\n    if (update.selectionSet || update.geometryChanged || update.viewportChanged) {\n      this.view.requestMeasure(this.measureReq);\n      this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n    }\n    if (configChanged(update)) this.setBlinkRate();\n  }\n  scheduleRedraw() {\n    this.view.requestMeasure(this.measureReq);\n  }\n  readPos() {\n    let {\n      state\n    } = this.view;\n    let cursors = [];\n    for (let r of state.selection.ranges) {\n      let prim = r == state.selection.main;\n      let piece = measureCursor(this.cm, this.view, r, prim);\n      if (piece) cursors.push(piece);\n    }\n    return {\n      cursors\n    };\n  }\n  drawSel({\n    cursors\n  }) {\n    if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n      let oldCursors = this.cursorLayer.children;\n      if (oldCursors.length !== cursors.length) {\n        this.cursorLayer.textContent = \"\";\n        for (const c of cursors) this.cursorLayer.appendChild(c.draw());\n      } else {\n        cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n      }\n      this.cursors = cursors;\n    }\n  }\n  destroy() {\n    this.cursorLayer.remove();\n  }\n}\nfunction configChanged(update) {\n  return getDrawSelectionConfig(update.startState) != getDrawSelectionConfig(update.state);\n}\nconst themeSpec = {\n  \".cm-vimMode .cm-line\": {\n    \"& ::selection\": {\n      backgroundColor: \"transparent !important\"\n    },\n    \"&::selection\": {\n      backgroundColor: \"transparent !important\"\n    },\n    caretColor: \"transparent !important\"\n  },\n  \".cm-fat-cursor\": {\n    position: \"absolute\",\n    background: \"#ff9696\",\n    border: \"none\",\n    whiteSpace: \"pre\"\n  },\n  \"&:not(.cm-focused) .cm-fat-cursor\": {\n    background: \"none\",\n    outline: \"solid 1px #ff9696\",\n    color: \"transparent !important\"\n  }\n};\nconst hideNativeSelection = /*@__PURE__*/Prec.highest( /*@__PURE__*/EditorView.theme(themeSpec));\nfunction getBase(view) {\n  let rect = view.scrollDOM.getBoundingClientRect();\n  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n  return {\n    left: left - view.scrollDOM.scrollLeft,\n    top: rect.top - view.scrollDOM.scrollTop\n  };\n}\nfunction measureCursor(cm, view, cursor, primary) {\n  var _a, _b;\n  let head = cursor.head;\n  let fatCursor = false;\n  let hCoeff = 1;\n  let vim = cm.state.vim;\n  if (vim && (!vim.insertMode || cm.state.overwrite)) {\n    fatCursor = true;\n    if (vim.visualBlock && !primary) return null;\n    if (cursor.anchor < cursor.head) head--;\n    if (cm.state.overwrite) hCoeff = 0.2;else if (vim.status) hCoeff = 0.5;\n  }\n  if (fatCursor) {\n    let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n    if (letter && /[\\uDC00-\\uDFFF]/.test(letter) && head > 1) {\n      // step back if cursor is on the second half of a surrogate pair\n      head--;\n      letter = view.state.sliceDoc(head, head + 1);\n    }\n    let pos = view.coordsAtPos(head, 1);\n    if (!pos) return null;\n    let base = getBase(view);\n    let domAtPos = view.domAtPos(head);\n    let node = domAtPos ? domAtPos.node : view.contentDOM;\n    while (domAtPos && domAtPos.node instanceof HTMLElement) {\n      node = domAtPos.node;\n      domAtPos = {\n        node: domAtPos.node.childNodes[domAtPos.offset],\n        offset: 0\n      };\n    }\n    if (!(node instanceof HTMLElement)) {\n      if (!node.parentNode) return null;\n      node = node.parentNode;\n    }\n    let style = getComputedStyle(node);\n    let left = pos.left;\n    // TODO remove coordsAtPos when all supported versions of codemirror have coordsForChar api\n    let charCoords = (_b = (_a = view).coordsForChar) === null || _b === void 0 ? void 0 : _b.call(_a, head);\n    if (charCoords) {\n      left = charCoords.left;\n    }\n    if (!letter || letter == \"\\n\" || letter == \"\\r\") {\n      letter = \"\\xa0\";\n    } else if (letter == \"\\t\") {\n      letter = \"\\xa0\";\n      var nextPos = view.coordsAtPos(head + 1, -1);\n      if (nextPos) {\n        left = nextPos.left - (nextPos.left - pos.left) / parseInt(style.tabSize);\n      }\n    } else if (/[\\uD800-\\uDBFF]/.test(letter) && head < view.state.doc.length - 1) {\n      // include the second half of a surrogate pair in cursor\n      letter += view.state.sliceDoc(head + 1, head + 2);\n    }\n    let h = pos.bottom - pos.top;\n    return new Piece(left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? \"cm-fat-cursor cm-cursor-primary\" : \"cm-fat-cursor cm-cursor-secondary\", letter, hCoeff != 1);\n  } else {\n    return null;\n  }\n}\nvar FIREFOX_LINUX = typeof navigator != \"undefined\" && /*@__PURE__*/ /linux/i.test(navigator.platform) && /*@__PURE__*/ / Gecko\\/\\d+/.exec(navigator.userAgent);\nconst Vim = /*@__PURE__*/initVim(CodeMirror);\nconst HighlightMargin = 250;\nconst vimStyle = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)\": {\n    display: \"none\"\n  },\n  \".cm-vim-panel\": {\n    padding: \"0px 10px\",\n    fontFamily: \"monospace\",\n    minHeight: \"1.3em\"\n  },\n  \".cm-vim-panel input\": {\n    border: \"none\",\n    outline: \"none\",\n    backgroundColor: \"inherit\"\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  }\n});\nconst vimPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.status = \"\";\n    this.query = null;\n    this.decorations = Decoration.none;\n    this.waitForCopy = false;\n    this.lastKeydown = '';\n    this.useNextTextInput = false;\n    this.compositionText = '';\n    this.view = view;\n    const cm = this.cm = new CodeMirror(view);\n    Vim.enterVimMode(this.cm);\n    this.view.cm = this.cm;\n    this.cm.state.vimPlugin = this;\n    this.blockCursor = new BlockCursorPlugin(view, cm);\n    this.updateClass();\n    this.cm.on(\"vim-command-done\", () => {\n      if (cm.state.vim) cm.state.vim.status = \"\";\n      this.blockCursor.scheduleRedraw();\n      this.updateStatus();\n    });\n    this.cm.on(\"vim-mode-change\", e => {\n      if (!cm.state.vim) return;\n      cm.state.vim.mode = e.mode;\n      if (e.subMode) {\n        cm.state.vim.mode += \" block\";\n      }\n      cm.state.vim.status = \"\";\n      this.blockCursor.scheduleRedraw();\n      this.updateClass();\n      this.updateStatus();\n    });\n    this.cm.on(\"dialog\", () => {\n      if (this.cm.state.statusbar) {\n        this.updateStatus();\n      } else {\n        view.dispatch({\n          effects: showVimPanel.of(!!this.cm.state.dialog)\n        });\n      }\n    });\n    this.dom = document.createElement(\"span\");\n    this.dom.style.cssText = \"position: absolute; right: 10px; top: 1px\";\n    this.statusButton = document.createElement(\"span\");\n    this.statusButton.onclick = e => {\n      Vim.handleKey(this.cm, \"<Esc>\", \"user\");\n      this.cm.focus();\n    };\n    this.statusButton.style.cssText = \"cursor: pointer\";\n  }\n  update(update) {\n    var _a;\n    if ((update.viewportChanged || update.docChanged) && this.query) {\n      this.highlight(this.query);\n    }\n    if (update.docChanged) {\n      this.cm.onChange(update);\n    }\n    if (update.selectionSet) {\n      this.cm.onSelectionChange();\n    }\n    if (update.viewportChanged) ;\n    if (this.cm.curOp && !this.cm.curOp.isVimOp) {\n      this.cm.onBeforeEndOperation();\n    }\n    if (update.transactions) {\n      for (let tr of update.transactions) for (let effect of tr.effects) {\n        if (effect.is(setSearchQuery)) {\n          let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;\n          if (!forVim) {\n            this.highlight(null);\n          } else {\n            let query = effect.value.create();\n            this.highlight(query);\n          }\n        }\n      }\n    }\n    this.blockCursor.update(update);\n  }\n  updateClass() {\n    const state = this.cm.state;\n    if (!state.vim || state.vim.insertMode && !state.overwrite) this.view.scrollDOM.classList.remove(\"cm-vimMode\");else this.view.scrollDOM.classList.add(\"cm-vimMode\");\n  }\n  updateStatus() {\n    let dom = this.cm.state.statusbar;\n    let vim = this.cm.state.vim;\n    if (!dom || !vim) return;\n    let dialog = this.cm.state.dialog;\n    if (dialog) {\n      if (dialog.parentElement != dom) {\n        dom.textContent = \"\";\n        dom.appendChild(dialog);\n      }\n    } else {\n      dom.textContent = \"\";\n      var status = (vim.mode || \"normal\").toUpperCase();\n      if (vim.insertModeReturn) status += \"(C-O)\";\n      this.statusButton.textContent = `--${status}--`;\n      dom.appendChild(this.statusButton);\n    }\n    this.dom.textContent = vim.status;\n    dom.appendChild(this.dom);\n  }\n  destroy() {\n    Vim.leaveVimMode(this.cm);\n    this.updateClass();\n    this.blockCursor.destroy();\n    delete this.view.cm;\n  }\n  highlight(query) {\n    this.query = query;\n    if (!query) return this.decorations = Decoration.none;\n    let {\n      view\n    } = this;\n    let builder = new RangeSetBuilder();\n    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n      let {\n        from,\n        to\n      } = ranges[i];\n      while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin) to = ranges[++i].to;\n      query.highlight(view.state, from, to, (from, to) => {\n        builder.add(from, to, matchMark);\n      });\n    }\n    return this.decorations = builder.finish();\n  }\n  handleKey(e, view) {\n    const cm = this.cm;\n    let vim = cm.state.vim;\n    if (!vim) return;\n    const key = Vim.vimKeyFromEvent(e, vim);\n    CodeMirror.signal(this.cm, 'inputEvent', {\n      type: \"handleKey\",\n      key\n    });\n    if (!key) return;\n    // clear search highlight\n    if (key == \"<Esc>\" && !vim.insertMode && !vim.visualMode && this.query /* && !cm.inMultiSelectMode*/) {\n      const searchState = vim.searchState_;\n      if (searchState) {\n        cm.removeOverlay(searchState.getOverlay());\n        searchState.setOverlay(null);\n      }\n    }\n    let isCopy = key === \"<C-c>\" && !CodeMirror.isMac;\n    if (isCopy && cm.somethingSelected()) {\n      this.waitForCopy = true;\n      return true;\n    }\n    vim.status = (vim.status || \"\") + key;\n    let result = Vim.multiSelectHandleKey(cm, key, \"user\");\n    vim = Vim.maybeInitVimState_(cm); // the object can change if there is an exception in handleKey\n    // insert mode\n    if (!result && vim.insertMode && cm.state.overwrite) {\n      if (e.key && e.key.length == 1 && !/\\n/.test(e.key)) {\n        result = true;\n        cm.overWriteSelection(e.key);\n      } else if (e.key == \"Backspace\") {\n        result = true;\n        CodeMirror.commands.cursorCharLeft(cm);\n      }\n    }\n    if (result) {\n      CodeMirror.signal(this.cm, 'vim-keypress', key);\n      e.preventDefault();\n      e.stopPropagation();\n      this.blockCursor.scheduleRedraw();\n    }\n    this.updateStatus();\n    return !!result;\n  }\n}, {\n  eventHandlers: {\n    copy: function (e, view) {\n      if (!this.waitForCopy) return;\n      this.waitForCopy = false;\n      Promise.resolve().then(() => {\n        var cm = this.cm;\n        var vim = cm.state.vim;\n        if (!vim) return;\n        if (vim.insertMode) {\n          cm.setSelection(cm.getCursor(), cm.getCursor());\n        } else {\n          cm.operation(() => {\n            if (cm.curOp) cm.curOp.isVimOp = true;\n            Vim.handleKey(cm, '<Esc>', 'user');\n          });\n        }\n      });\n    },\n    compositionstart: function (e, view) {\n      this.useNextTextInput = true;\n      CodeMirror.signal(this.cm, 'inputEvent', e);\n    },\n    compositionupdate: function (e, view) {\n      CodeMirror.signal(this.cm, 'inputEvent', e);\n    },\n    compositionend: function (e, view) {\n      CodeMirror.signal(this.cm, 'inputEvent', e);\n    },\n    keypress: function (e, view) {\n      CodeMirror.signal(this.cm, 'inputEvent', e);\n      if (this.lastKeydown == \"Dead\") this.handleKey(e, view);\n    },\n    keydown: function (e, view) {\n      CodeMirror.signal(this.cm, 'inputEvent', e);\n      this.lastKeydown = e.key;\n      if (this.lastKeydown == \"Unidentified\" || this.lastKeydown == \"Process\" || this.lastKeydown == \"Dead\") {\n        this.useNextTextInput = true;\n      } else {\n        this.useNextTextInput = false;\n        this.handleKey(e, view);\n      }\n    }\n  },\n  provide: () => {\n    return [EditorView.inputHandler.of((view, from, to, text) => {\n      var _a, _b;\n      var cm = getCM(view);\n      if (!cm) return false;\n      var vim = (_a = cm.state) === null || _a === void 0 ? void 0 : _a.vim;\n      var vimPlugin = cm.state.vimPlugin;\n      if (vim && !vim.insertMode && !((_b = cm.curOp) === null || _b === void 0 ? void 0 : _b.isVimOp)) {\n        if (text === \"\\0\\0\") {\n          return true;\n        }\n        CodeMirror.signal(cm, 'inputEvent', {\n          type: \"text\",\n          text,\n          from,\n          to\n        });\n        if (text.length == 1 && vimPlugin.useNextTextInput) {\n          if (vim.expectLiteralNext && view.composing) {\n            vimPlugin.compositionText = text;\n            return false;\n          }\n          if (vimPlugin.compositionText) {\n            var toRemove = vimPlugin.compositionText;\n            vimPlugin.compositionText = '';\n            var head = view.state.selection.main.head;\n            var textInDoc = view.state.sliceDoc(head - toRemove.length, head);\n            if (toRemove === textInDoc) {\n              var pos = cm.getCursor();\n              cm.replaceRange('', cm.posFromIndex(head - toRemove.length), pos);\n            }\n          }\n          vimPlugin.handleKey({\n            key: text,\n            preventDefault: () => {},\n            stopPropagation: () => {}\n          });\n          forceEndComposition(view);\n          return true;\n        }\n      }\n      return false;\n    })];\n  },\n  decorations: v => v.decorations\n});\n/**\n * removes contenteditable element and adds it back to end\n * IME composition in normal mode\n * this method works on all browsers except for Firefox on Linux\n * where we need to reset textContent of editor\n * (which doesn't work on other browsers)\n */\nfunction forceEndComposition(view) {\n  var parent = view.scrollDOM.parentElement;\n  if (!parent) return;\n  if (FIREFOX_LINUX) {\n    view.contentDOM.textContent = \"\\0\\0\";\n    view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n    return;\n  }\n  var sibling = view.scrollDOM.nextSibling;\n  var selection = window.getSelection();\n  var savedSelection = selection && {\n    anchorNode: selection.anchorNode,\n    anchorOffset: selection.anchorOffset,\n    focusNode: selection.focusNode,\n    focusOffset: selection.focusOffset\n  };\n  view.scrollDOM.remove();\n  parent.insertBefore(view.scrollDOM, sibling);\n  try {\n    if (savedSelection && selection) {\n      selection.setPosition(savedSelection.anchorNode, savedSelection.anchorOffset);\n      if (savedSelection.focusNode) {\n        selection.extend(savedSelection.focusNode, savedSelection.focusOffset);\n      }\n    }\n  } catch (e) {\n    console.error(e);\n  }\n  view.focus();\n  view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch\"\n});\nconst showVimPanel = /*@__PURE__*/StateEffect.define();\nconst vimPanelState = /*@__PURE__*/StateField.define({\n  create: () => false,\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(showVimPanel)) value = e.value;\n    return value;\n  },\n  provide: f => {\n    return showPanel.from(f, on => on ? createVimPanel : null);\n  }\n});\nfunction createVimPanel(view) {\n  let dom = document.createElement(\"div\");\n  dom.className = \"cm-vim-panel\";\n  let cm = view.cm;\n  if (cm.state.dialog) {\n    dom.appendChild(cm.state.dialog);\n  }\n  return {\n    top: false,\n    dom\n  };\n}\nfunction statusPanel(view) {\n  let dom = document.createElement(\"div\");\n  dom.className = \"cm-vim-panel\";\n  let cm = view.cm;\n  cm.state.statusbar = dom;\n  cm.state.vimPlugin.updateStatus();\n  return {\n    dom\n  };\n}\nfunction vim(options = {}) {\n  return [vimStyle, vimPlugin, hideNativeSelection, options.status ? showPanel.of(statusPanel) : vimPanelState];\n}\nfunction getCM(view) {\n  return view.cm || null;\n}\nexport { CodeMirror, Vim, getCM, vim };","map":{"version":3,"names":["EditorSelection","MapMode","Prec","RangeSetBuilder","StateEffect","StateField","foldCode","matchBrackets","indentUnit","ensureSyntaxTree","StringStream","View","runScopeHandlers","EditorView","Direction","ViewPlugin","Decoration","showPanel","SearchQuery","setSearchQuery","RegExpCursor","indentMore","indentLess","cursorLineBoundaryBackward","cursorLineBoundaryForward","cursorCharBackward","cursorCharLeft","insertNewlineAndIndent","indentSelection","undo","redo","initVim","CodeMirror","Pos","updateSelectionForSurrogateCharacters","cm","curStart","curEnd","line","ch","text","getLine","charCode","charCodeAt","start","end","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","keepCursor","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","replace","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","length","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","langmap","parseLangmap","enterVimMode","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","highlightTimeout","clearTimeout","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","test","bigWordCharTest","validMarks","validRegisters","latinCharRegex","upperCaseChars","RegExp","_","isLine","firstLine","lastLine","isLowerCase","k","isMatchableSymbol","indexOf","isNumber","isUpperCase","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","val","arr","i","options","defineOption","defaultValue","aliases","callback","undefined","Error","value","cfg","option","scope","getOption","local","width","column","Math","round","createCircularJumpList","size","pointer","head","tail","buffer","Array","add","oldCur","newCur","current","curMark","useNextSlot","cursor","next","trashMark","clear","setBookmark","markPos","find","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","constructor","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","template","dom","class","bottom","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","marks","insertModeReturn","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","expectLiteralNext","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","increment","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","mapclear","actualLength","origLength","userKeymap","slice","mapping","_mapCommand","contexts","j","newMapping","Object","assign","updateLangmap","vimKeyFromEvent","defineEx","prefix","func","exCommands","commandMap_","handleKey","key","origin","command","findKey","multiSelectHandleKey","cm_","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","handleKeyInsertMode","keyBuffer","push","join","keysAreChars","match","commandDispatcher","matchCommand","changeQueue","window","setTimeout","selections","listSelections","removed","ChangeQueue","inserted","from","cursorMin","anchor","to","cursorMax","getRange","overwrite","here","replaceRange","pop","handleKeyNonInsertMode","keysMatcher","exec","mainKey","operatorShortcut","pushRepeatDigit","operation","curOp","isVimOp","doKeyToKey","processCommand","e","console","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","keyToKeyStack","virtualPrompt","sendKeyToPrompt","lowerKey","toLowerCase","parts","split","vimToCmKeyMap","event","target","selectionEnd","selectionStart","onKeyDown","close","onKeyUp","prompt","onClose","fromKey","noremapBefore","keyRe","wasInsert","result","hasOwnProperty","sendCmKey","lastIndex","index","replaceSelection","promptOptions","showPrompt","specialKey","Return","Backspace","Escape","Insert","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Enter","ignoredKeys","Shift","Alt","Command","Control","CapsLock","AltGraph","Dead","Unidentified","concat","forEach","x","ctrlKey","altKey","metaKey","isMac","shiftKey","keymap","remapCtrl","code","langmapString","string","getEscaped","list","filter","Boolean","part","semicolon","pairs","prefixRepeat","motionRepeat","n","getRepeat","repeat","parseInt","reason","Register","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","query","toString","registers","unnamedRegister","charAt","isValidRegister","shiftNumericRegisters_","append","navigator","clipboard","writeText","historyBuffer","iterator","initialPrefix","nextMatch","up","dir","element","substring","pushInput","splice","reset","keyMap","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","ignoreCase","smartCase","updateSearchQuery","showConfirm","onPromptClose","scrollTo","left","top","logSearchQuery","onPromptKeyUp","keyName","min","parsedQuery","scrollIntoView","findNext","clearSearchHighlight","onPromptKeyDown","e_stop","focus","shift","desc","word","expandWordUnderCursor","noSymbol","isKeyword","escapeRegex","exArgs","selectValueOnOpen","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","cmSel","newPositions","makeCmSelection","ranges","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","setSelections","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","range","floor","moveToBottomLine","expandToLine","_cm","cur","prev","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","posV","findPosV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","getTokenTypeAt","re","matched","findMatchingBracket","bracketRegex","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","execCommand","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","sc","findBeginningAndEnd","repeated","innerWord","multiline","expandTagUnderCursor","content","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fn","fillArray","times","change","args","finalHead","lastState","Number","MAX_VALUE","setSelection","getSelection","replacement","replaceSelections","delete","indent","startLine","endLine","indentLine","indentAuto","_args","hardWrap","endRow","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","toggleOverwrite","newPosition","max","getLastEditPos","onChange","insertEnd","insertLeft","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","nextStartCh","nextLine","search","curFinalPos","newLineAndEnterInsertMode","newlineFn","commands","newlineAndIndentContinueComment","newlineAndIndent","paste","readText","then","continuePaste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","repeatFn","setRegister","insertRegister","oneNormalCommand","handler","setMark","markName","replaceWith","replaceTo","replaceWithStr","replaceWithStrings","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","substr","repeatLastEdit","includeLineBreak","maxCh","direction","ret","prop","offsetLine","offsetCh","startIndex","commandMatch","pressed","mapped","isLastCharacter","isLastRegister","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","prototype","call","cur3","cur1before2","cur2before3","trim","s","clipPos","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","selection","lines","firstNonWS","startLineNumber","endLineNumber","idx","wordOnNextLine","findWord","startsWithSpace","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","found","method","preprocess","token","lineCount","curCh","lineLen","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","nextChar","curr","ln","lastSentencePos","reverse","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","startBracket","scanForBracket","endBracket","chars","len","firstIndex","stringAfter","stringBefore","isStringStart","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","output","eol","peek","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","document","createElement","a","createTextNode","nodeType","appendChild","setAttribute","pre","$color","$whiteSpace","openNotification","duration","alert","innerText","makePrompt","$display","$fontFamily","$flex","autocorrect","autocapitalize","spellcheck","$width","shortText","textContent","regexEqual","r1","r2","props","rawQuery","source","matchSol","sol","skipToEnd","backUp","searchState","removeOverlay","addOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","getLastEditEnd","done","doc","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","selectionLine","selectionLineEnd","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","defaultOnly","mapArgs","imap","nmap","vmap","omap","inoremap","nnoremap","vnoremap","onoremap","imapclear","nmapclear","vmapclear","omapclear","set","setArgs","setCfg","expr","forceGet","forceToggle","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","registerNames","sort","unique","pattern","parseArgs","eatSpace","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","compareFn","b","amatch","bmatch","anum","bnum","comparePatternFn","textOld","vglobal","global","normal","trimStart","isNaN","inverted","cmd","matchedLines","getLineHandle","nextCommand","lineHandle","getLineNumber","releaseLineHandles","substitute","replacePart","trailing","count","confirm","startPos","doReplace","startinsert","write","save","nohlsearch","delmarks","sym","startMark","finishMark","finish","String","fromCharCode","searchCursor","exMode","lastPos","modifiedLineNumber","joined","replaceAll","newText","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","somethingSelected","repeatForInsert","lastAction","cachedInputState","repeatCommand","repeatInsert","changeObject","lookupKey","keyHandler","binding","cloneVimState","o","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","old","changeQueueList","forEachSelection","virtualSelection","cursorActivity","insert","lineNumber","lineAt","emitter","f","addEventListener","_handlers","removeEventListener","_a","handlers","signalTo","wordChar","dispatchChange","transaction","view","cm6","readOnly","annotations","some","note","error","userEvent","dispatch","runHistoryCommand","revert","$changeStart","changeStartIndex","create","$mid","$lastChangeEndOffset","bind","onSelectionChange","tmpRanges","onBeforeEndOperation","p","main","r","row","$lineHandleChanges","handle","updates","mapPos","TrackAfter","sliceDoc","replacements","empty","contentDOM","getValue","setValue","blur","defaultLineHeight","_options","m","config","more","log","assoc","bm","Marker","cm6Query","caseSensitive","flags","valid","forVim","effect","of","effects","lastCM5Result","firstOffset","rCursor","ChunkSize","prevMatchInRange","findPrevious","back","endAt","startFrom","amount","unit","goalColumn","pixels","startOffset","moveVertically","rect","getBoundingClientRect","coords","coordsAtPos","d","posAtCoords","scroller","scrollDOM","scrollLeft","scrollTop","scrollHeight","scrollWidth","clientWidth","margin","getWrapperElement","getMode","setSize","w","h","refresh","measure","destroy","update","iterChanges","fromA","toA","fromB","toB","toJSON","changeHandlers","cursorActivityHandlers","force","$d","op","textwidth","facet","tree","node","resolve","overWriteSelection","sliceString","mainIndex","virtualSelectionMode","platform","tr","addClass","el","rmClass","e_preventDefault","preventDefault","_b","stopPropagation","dialogDiv","dialog","closeNotification","newVal","currentNotificationClose","closed","doneTimer","remove","hideDialog","onclick","showDialog","oldDialog","contains","activeElement","parentElement","replaceChild","me","inp","getElementsByTagName","select","onInput","keyCode","closeOnEnter","closeOnBlur","matching","where","maxScanLen","maxScanLineLength","maxScanLines","stack","lineNo","firstChild","lastChild","convertRange","parent","cm6Range","id","TrackDel","allowMerge","space","findSpace","indentation","trimmedLine","trimmedNextLine","mergedLine","before","spaceAfter","spaceBefore","getDrawSelectionConfig","defaultConfig","cursorBlinkRate","Piece","fontFamily","fontSize","fontWeight","color","className","letter","draw","elt","adjust","eq","BlockCursorPlugin","rangePieces","cursors","measureReq","read","readPos","drawSel","cursorLayer","requestMeasure","setBlinkRate","blinkRate","animationDuration","selectionSet","geometryChanged","viewportChanged","animationName","configChanged","scheduleRedraw","prim","piece","measureCursor","oldCursors","children","themeSpec","backgroundColor","caretColor","background","border","whiteSpace","outline","hideNativeSelection","highest","theme","getBase","textDirection","LTR","right","fatCursor","hCoeff","domAtPos","HTMLElement","childNodes","parentNode","getComputedStyle","coordsForChar","nextPos","FIREFOX_LINUX","userAgent","Vim","HighlightMargin","vimStyle","baseTheme","display","padding","minHeight","vimPlugin","fromClass","decorations","none","waitForCopy","lastKeydown","useNextTextInput","compositionText","blockCursor","updateClass","updateStatus","statusbar","showVimPanel","cssText","statusButton","docChanged","highlight","transactions","is","classList","builder","visibleRanges","l","matchMark","isCopy","eventHandlers","copy","Promise","compositionstart","compositionupdate","compositionend","keypress","keydown","provide","inputHandler","getCM","composing","toRemove","textInDoc","forceEndComposition","v","dispatchEvent","CustomEvent","sibling","nextSibling","savedSelection","anchorNode","focusNode","focusOffset","insertBefore","setPosition","extend","define","vimPanelState","createVimPanel","statusPanel"],"sources":["/Users/macbookpro/Documents/angular-13-hbcxd6/node_modules/@replit/codemirror-vim/dist/index.js"],"sourcesContent":["import { EditorSelection, MapMode, Prec, RangeSetBuilder, StateEffect, StateField } from '@codemirror/state';\nimport { foldCode, matchBrackets, indentUnit, ensureSyntaxTree, StringStream } from '@codemirror/language';\nimport * as View from '@codemirror/view';\nimport { runScopeHandlers, EditorView, Direction, ViewPlugin, Decoration, showPanel } from '@codemirror/view';\nimport { SearchQuery, setSearchQuery, RegExpCursor } from '@codemirror/search';\nimport { indentMore, indentLess, cursorLineBoundaryBackward, cursorLineBoundaryForward, cursorCharBackward, cursorCharLeft, insertNewlineAndIndent, indentSelection, undo, redo } from '@codemirror/commands';\n\n//@ts-check\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n/**\n * @typedef { import(\"./cm_adapter\").CodeMirror } CodeMirror\n * @typedef { import(\"./types\").CodeMirrorV} CodeMirrorV\n * @typedef { import(\"./types\").Pos } Pos\n * @typedef { import(\"./types\").CM5Range } CM5Range\n * @typedef { import(\"./types\").vimState } vimState \n * @typedef { import(\"./types\").ExFn } ExFn\n * @typedef { import(\"./types\").MotionArgs } MotionArgs\n * @typedef { import(\"./types\").ActionArgs } ActionArgs\n * @typedef { import(\"./types\").OperatorArgs } OperatorArgs\n * @typedef { import(\"./types\").vimKey } vimKey\n * @typedef { import(\"./types\").InputStateInterface } InputStateInterface\n */\n\n/** @arg {typeof import(\"./cm_adapter\").CodeMirror} CodeMirror */\nfunction initVim(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  /** @arg {CodeMirror} cm @arg {Pos} curStart @arg {Pos} curEnd */\n  function updateSelectionForSurrogateCharacters(cm, curStart, curEnd) {\n    // start and character position when no selection \n    // is the same in visual mode, and differs in 1 character in normal mode\n    if (curStart.line === curEnd.line && curStart.ch >= curEnd.ch - 1) {\n      var text = cm.getLine(curStart.line);\n      var charCode = text.charCodeAt(curStart.ch);\n      if (0xD800 <= charCode && charCode <= 0xD8FF) {\n        curEnd.ch += 1;\n      }\n    }\n\n    return {start: curStart, end: curEnd};\n  }\n  /** @type {import(\"./types\").vimKeyMap} */\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x' },\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<register>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<register>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    { keys: 'gq', type: 'operator', operator: 'hardWrap' },\n    { keys: 'gw', type: 'operator', operator: 'hardWrap', operatorArgs: {keepCursor: true}},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<register>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<register>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<register>', type: 'action', action: 'setMark' },\n    { keys: '\"<register>', type: 'action', action: 'setRegister' },\n    { keys: '<C-r><register>', type: 'action', action: 'insertRegister', context: 'insert', isEdit: true },\n    { keys: '<C-o>', type: 'action', action: 'oneNormalCommand', context: 'insert' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<register>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<register>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'omap', shortName: 'om' },\n    { name: 'noremap', shortName: 'no' },\n    { name: 'nnoremap', shortName: 'nn' },\n    { name: 'vnoremap', shortName: 'vn' },\n    { name: 'inoremap', shortName: 'ino' },\n    { name: 'onoremap', shortName: 'ono' },\n    { name: 'unmap' },\n    { name: 'mapclear', shortName: 'mapc' },\n    { name: 'nmapclear', shortName: 'nmapc' },\n    { name: 'vmapclear', shortName: 'vmapc' },\n    { name: 'imapclear', shortName: 'imapc' },\n    { name: 'omapclear', shortName: 'omapc' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'startinsert', shortName: 'start' },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'delete', shortName: 'd' },\n    { name: 'join', shortName: 'j' },\n    { name: 'normal', shortName: 'norm' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  /**\n   * Langmap\n   * Determines how to interpret keystrokes in Normal and Visual mode.\n   * Useful for people who use a different keyboard layout than QWERTY\n   */\n  var langmap = parseLangmap('');\n\n  /** @arg {CodeMirror} cm */\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    // @ts-ignore\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n\n  /** @arg {CodeMirror} cm */\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    // @ts-ignore\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n  }\n\n  /** @arg {CodeMirrorV} cm */\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function() {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n    return vim.onPasteFn;\n  }\n\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n    return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n  }], bigWordCharTest = [function(ch) {\n    return /\\S/.test(ch);\n  }];\n  var validMarks = ['<', '>'];\n  var validRegisters = ['-', '\"', '.', ':', '_', '/', '+'];\n  var latinCharRegex = /^\\w$/;\n  var upperCaseChars;\n  try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n  catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n  /** @arg {CodeMirror} cm @arg {number} line */\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  /** @arg {string} k */\n  function isLowerCase(k) {\n    return (/^[a-z]$/).test(k);\n  }\n  /** @arg {string} k */\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n  /** @arg {string} k */\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  /** @arg {string} k */\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  /** @arg {string} k */\n  function isWhiteSpaceString(k) {\n    return (/^\\s*$/).test(k);\n  }\n  /** @arg {string} k */\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n  /** @arg {any} val @arg {string | any[]} arr */\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n  /** @typedef {import(\"./types\").optionCallback} optionCallback */\n  /** @typedef {import(\"./types\").vimOption} vimOption */\n  /** @type {Object<string, vimOption>} */\n  var options = {};\n  /** \n   * @arg {string} name \n   * @arg {any} defaultValue \n   * @arg {string} type \n   * @arg {string[] } [aliases] \n   * @arg {optionCallback} [callback] \n   * */\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n    if (!type) { type = 'string'; }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  /**\n   * @arg {string} name \n   * @arg {any} value \n   * @arg {CodeMirrorV} [cm] \n   * @arg {{ scope?: any; } | undefined} [cfg] */\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        // Boolean options are set to true if value is not defined.\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {value: value};\n      }\n    }\n  }\n\n  /** \n   * @arg {string} name \n   * @arg {CodeMirrorV} [cm] \n   * @arg {{ scope?: any; } | undefined} [cfg] */\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n    if (option.callback) {\n      let local = cm && option.callback(undefined, cm);\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n      if (scope !== 'local') {\n        return option.callback();\n      }\n      return;\n    } else {\n      let local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n      return (local || (scope !== 'local') && option || {}).value;\n    }\n  }\n  /** @arg {string|undefined} name @arg {CodeMirrorV} [cm] */\n  defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      let mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      let mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n  defineOption('textwidth', 80, 'number', ['tw'], function(width, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (width === undefined) {\n      var value = cm.getOption('textwidth');\n      return value;\n    } else {\n      var column = Math.round(/**@type {any}*/(width));\n      if (column > 1) {\n        cm.setOption('textwidth', column);\n      }\n    }\n  });\n\n  var createCircularJumpList = function() {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    /** @arg {CodeMirror} cm  @arg {any} oldCur @arg {any} newCur */\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      /** @arg {Pos} cursor */\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        // avoid recording redundant cursor position\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    /** @arg {CodeMirror} cm  @arg {number} offset */\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      // skip marks that are temporarily removed from text buffer\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          // skip marks that are the same as current position\n          if (mark &&\n              (newCur = mark.find()) &&\n              !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    /** @arg {CodeMirror} cm @arg {number} offset */\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined, //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n\n  /** \n   * Returns an object to track the changes associated insert mode.  It\n   * clones the object that is passed in, or creates an empty object one if\n   * none is provided.\n   * @arg {import(\"./types\").InsertModeChanges | undefined} [c]\n   * @returns {import(\"./types\").InsertModeChanges} \n   */\n  var createInsertModeChanges = function(c) {\n    if (c) {\n      // Copy construction\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n    return {\n      // Change list\n      changes: [],\n      // Set to true on change, false on cursorActivity.\n      expectCursorActivityForChange: false\n    };\n  };\n\n  class MacroModeState {\n    constructor() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    exitMacroRecordMode() {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    }\n    enterMacroRecordMode(cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n          this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n        }\n        this.isRecording = true;\n      }\n    }\n  }\n  /**\n   * @arg Codemirror\n   * @return {vimState}\n   */\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      // Store instance state in the CodeMirror object.\n      cm.state.vim = {\n        inputState: new InputState(),\n        // Vim's input state that triggered the last edit, used to repeat\n        // motions and operators with '.'.\n        lastEditInputState: undefined,\n        // Vim's action command before the last edit, used to repeat actions\n        // with '.' and insert mode repeat.\n        lastEditActionCommand: undefined,\n        // When using jk for navigation, if you move from a longer line to a\n        // shorter line, the cursor may clip to the end of the shorter line.\n        // If j is pressed again and cursor goes to the next line, the\n        // cursor should go back to its horizontal position on the longer\n        // line if it can. This is to keep track of the horizontal position.\n        lastHPos: -1,\n        // Doing the same with screen-position for gj/gk\n        lastHSPos: -1,\n        // The last motion command run. Cleared if a non-motion command gets\n        // executed in between.\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        insertModeReturn: false,\n        // Repeat count for changes made in insert mode, triggered by key\n        // sequences like 3,i. Only exists when insertMode is true.\n        insertModeRepeat: undefined,\n        visualMode: false,\n        // If we are in visual line mode. No effect if visualMode is false.\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        // Buffer-local/window-local values of vim options.\n        options: {},\n        // Whether the next character should be interpreted literally\n        // Necassary for correct implementation of f<character>, r<character> etc.\n        // in terms of langmaps.\n        expectLiteralNext: false\n      };\n    }\n    return cm.state.vim;\n  }\n  /**\n   * @type { \n      {\n        macroModeState: MacroModeState;\n        registerController: RegisterController;\n        searchHistoryController: HistoryController;\n        jumpList: any;\n        exCommandHistoryController: HistoryController; \n        lastCharacterSearch: any; \n        query?: any;\n        isReversed?: any;\n        lastSubstituteReplacePart: any;\n        searchQuery?: null; \n        searchIsReversed?: boolean; \n      }\n    }\n  */\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      // The current search query.\n      searchQuery: null,\n      // Whether we are searching backwards.\n      searchIsReversed: false,\n      // Replace part of the last substituted pattern\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      // Recording latest f, t, F or T motion command.\n      lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n      registerController: new RegisterController({}),\n      // search history buffer\n      searchHistoryController: new HistoryController(),\n      // ex Command history buffer\n      exCommandHistoryController : new HistoryController()\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  /** @type {number | undefined|false} */\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    enterVimMode: enterVimMode,\n    leaveVimMode: leaveVimMode,\n    buildKeyMap: function() {\n      // TODO: Convert keymap into dictionary format for fast lookup.\n    },\n    // Testing hook, though it might be useful to expose the register\n    // controller anyway.\n    getRegisterController: function() {\n      return vimGlobalState.registerController;\n    },\n    // Testing hook.\n    resetVimGlobalState_: resetVimGlobalState,\n\n    // Testing hook.\n    getVimGlobalState_: function() {\n      return vimGlobalState;\n    },\n\n    // Testing hook.\n    maybeInitVimState_: maybeInitVimState,\n\n    suppressErrorLogging: false,\n\n    InsertModeKey: InsertModeKey,\n    /**@type {(lhs: string, rhs: string, ctx: string) => void} */\n    map: function(lhs, rhs, ctx) {\n      // Add user defined key bindings.\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    /**@type {(lhs: string, ctx: string) => any} */\n    unmap: function(lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    // Non-recursive map function.\n    // NOTE: This will not create mappings to key maps that aren't present\n    // in the default key map. See TODO at bottom of function.\n    /**@type {(lhs: string, rhs: string, ctx: string) => void} */\n    noremap: function(lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx, true);\n    },\n    // Remove all user-defined mappings for the provided context.\n    /**@arg {string} [ctx]} */\n    mapclear: function(ctx) {\n      // Partition the existing keymap into user-defined and true defaults.\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        // If a specific context is being cleared, we need to keep mappings\n        // from all other contexts.\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              // `mapping` applies to all contexts so create keymap copies\n              // for each context except the one being cleared.\n              var contexts = ['normal', 'insert', 'visual'];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = Object.assign({}, mapping);\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    langmap: updateLangmap,\n    vimKeyFromEvent: vimKeyFromEvent,\n    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    /**@type {(name: string, prefix: string|undefined, func: ExFn) => void} */\n    defineEx: function(name, prefix, func){\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n      }\n      exCommands[name]=func;\n      exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n    },\n    /**@type {(cm: CodeMirror, key: string, origin: string) => undefined | boolean} */\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    multiSelectHandleKey: multiSelectHandleKey,\n\n    /**\n     * This is the outermost function called by CodeMirror, after keys have\n     * been mapped to their Vim equivalents.\n     *\n     * Finds a command based on the key (and cached keys if there is a\n     * multi-key sequence). Returns `undefined` if no key is matched, a noop\n     * function if a partial match is found (multi-key), and a function to\n     * execute the bound command if a a key is matched. The function always\n     * returns true.\n     */\n    /**@type {(cm_: CodeMirror, key: string, origin?: string| undefined) => (() => boolean) | undefined} */\n    findKey: function(cm_, key, origin) {\n      var vim = maybeInitVimState(cm_);\n      var cm = /**@type {CodeMirrorV}*/(cm_);\n\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == '<Esc>') {\n          if (vim.visualMode) {\n            // Get back to normal mode.\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            // Get back to normal mode.\n            exitInsertMode(cm);\n          } else {\n            // We're already in normal mode. Let '<Esc>' be handled normally.\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n\n      function handleKeyInsertMode() {\n        if (handleEsc()) { return true; }\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n        var changeQueue = vim.inputState.changeQueue;\n\n        if (match.type == 'none') { clearInputState(cm); return false; }\n        else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          lastInsertModeKeyTimer = keysAreChars && window.setTimeout(\n            function() { if (vim.insertMode && vim.inputState.keyBuffer.length) { clearInputState(cm); } },\n            getOption('insertModeEscKeysTimeout'));\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            if (!changeQueue || changeQueue.removed.length != selections.length)\n              changeQueue = vim.inputState.changeQueue = new ChangeQueue;\n            changeQueue.inserted += key;\n            for (var i = 0; i < selections.length; i++) {\n              var from = cursorMin(selections[i].anchor, selections[i].head);\n              var to = cursorMax(selections[i].anchor, selections[i].head);\n              var text = cm.getRange(from, cm.state.overwrite ? offsetCursor(to, 0, 1) : to);\n              changeQueue.removed[i] = (changeQueue.removed[i] || \"\") + text;\n            }\n          }\n          return !keysAreChars;\n        }\n        vim.expectLiteralNext = false;\n\n        if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n        if (match.command && changeQueue) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(changeQueue.removed[i] || \"\", \n              offsetCursor(here, 0, -changeQueue.inserted.length), here, '+input');\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        if (!match.command) clearInputState(cm);\n        return match.command;\n      }\n\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) { return true; }\n\n        vim.inputState.keyBuffer.push(key);\n        var keys = vim.inputState.keyBuffer.join(\"\");\n        if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) { clearInputState(cm); return false; }\n        var context = vim.visualMode ? 'visual' :\n                                        'normal';\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n          // multikey operators act linewise by repeating only the last character\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n        if (match.type == 'none') { clearInputState(cm); return false; }\n        else if (match.type == 'partial') {\n          if (match.expectLiteralNext) vim.expectLiteralNext = true;\n          return true;\n        }\n        else if (match.type == 'clear') { clearInputState(cm); return true; }\n        vim.expectLiteralNext = false;\n\n        vim.inputState.keyBuffer.length = 0;\n        keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher && keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n\n      var command;\n      if (vim.insertMode) { command = handleKeyInsertMode(); }\n      else { command = handleKeyNonInsertMode(); }\n      if (command === false) {\n        return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n      } else if (command === true) {\n        // TODO: Look into using CodeMirror's multi-key handling.\n        // Return no-op since we are caching the key. Counts as handled, but\n        // don't want act on it just yet.\n        return function() { return true; };\n      } else {\n        return function() {\n          return cm.operation(function() {\n            // @ts-ignore\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(cm, command.toKeys, command);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              // clear VIM state in case it's in a bad state.\n              // @ts-ignore\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console['log'](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function(cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n\n    defineRegister: defineRegister,\n\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n\n  var keyToKeyStack = [];\n  var noremap = false;\n  var virtualPrompt;\n  function sendKeyToPrompt(key) {\n    if (key[0] == \"<\") {\n      var lowerKey = key.toLowerCase().slice(1, -1);\n      var parts = lowerKey.split('-');\n      lowerKey = parts.pop() || '';\n      if (lowerKey == 'lt') key = '<';\n      else if (lowerKey == 'space') key = ' ';\n      else if (lowerKey == 'cr') key = '\\n';\n      else if (vimToCmKeyMap[lowerKey]) {\n        var value = virtualPrompt.value;\n        var event =  {\n          key: vimToCmKeyMap[lowerKey],\n          target: {\n            value: value,\n            selectionEnd: value.length,\n            selectionStart: value.length\n          }\n        };\n        if (virtualPrompt.onKeyDown) {\n          virtualPrompt.onKeyDown(event, virtualPrompt.value, close);\n        }\n        if (virtualPrompt && virtualPrompt.onKeyUp) {\n          virtualPrompt.onKeyUp(event, virtualPrompt.value, close);\n        }\n        return;\n      }\n    }\n    if (key == '\\n') {\n      var prompt = virtualPrompt;\n      virtualPrompt = null;\n      prompt.onClose && prompt.onClose(prompt.value);\n    } else {\n      virtualPrompt.value = (virtualPrompt.value || '') + key;\n    }\n\n    function close(value) {\n      if (typeof value == 'string') { virtualPrompt.value = value; }\n      else { virtualPrompt = null; }\n    }\n  }\n  function doKeyToKey(cm, keys, fromKey) {\n    var noremapBefore = noremap;\n    // prevent infinite recursion.\n    if (fromKey) {\n      if (keyToKeyStack.indexOf(fromKey) != -1) return;\n      keyToKeyStack.push(fromKey);\n      noremap = fromKey.noremap != false;\n    }\n\n    try {\n      var vim = maybeInitVimState(cm);\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n\n      var match;\n      // Pull off one command key, which is either a single character\n      // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n      while ((match = keyRe.exec(keys))) {\n        var key = match[0];\n        var wasInsert = vim.insertMode;\n        if (virtualPrompt) {\n          sendKeyToPrompt(key);\n          continue;\n        }\n\n        var result = vimApi.handleKey(cm, key, 'mapping');\n\n        if (!result && wasInsert && vim.insertMode) {\n          if (key[0] == \"<\") {\n            var lowerKey = key.toLowerCase().slice(1, -1);\n            var parts = lowerKey.split('-');\n            lowerKey = parts.pop() || '';\n            if (lowerKey == 'lt') key = '<';\n            else if (lowerKey == 'space') key = ' ';\n            else if (lowerKey == 'cr') key = '\\n';\n            else if (vimToCmKeyMap.hasOwnProperty(lowerKey)) {\n              // todo support codemirror keys in insertmode vimToCmKeyMap\n              key = vimToCmKeyMap[lowerKey];\n              sendCmKey(cm, key);\n              continue;\n            } else {\n              key = key[0];\n              keyRe.lastIndex = match.index + 1;\n            }\n          }\n          cm.replaceSelection(key);\n        }\n      }\n    } finally {\n      keyToKeyStack.pop();\n      noremap = keyToKeyStack.length ? noremapBefore : false;\n      if (!keyToKeyStack.length && virtualPrompt) {\n        var promptOptions = virtualPrompt;\n        virtualPrompt = null;\n        showPrompt(cm, promptOptions);\n      }\n    }\n  }\n\n  var specialKey = {\n    Return: 'CR', Backspace: 'BS', 'Delete': 'Del', Escape: 'Esc', Insert: 'Ins',\n    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',\n    Enter: 'CR', ' ': 'Space'\n  };\n  var ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1,\n    CapsLock: 1, AltGraph: 1, Dead: 1, Unidentified: 1 };\n\n  var vimToCmKeyMap = {};\n  'Left|Right|Up|Down|End|Home'.split('|').concat(Object.keys(specialKey)).forEach(function(x) {\n    vimToCmKeyMap[(specialKey[x] || '').toLowerCase()]\n        = vimToCmKeyMap[x.toLowerCase()] = x;\n  });\n\n  function vimKeyFromEvent(e, vim) {\n    var key = e.key;\n    if (ignoredKeys[key]) return;\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"Numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n\n    var name = '';\n    if (e.ctrlKey) { name += 'C-'; }\n    if (e.altKey) { name += 'A-'; }\n    if (e.metaKey) { name += 'M-'; }\n    // on mac many characters are entered as option- combos\n    // (e.g. on swiss keyboard { is option-8)\n    // so we ignore lonely A- modifier for keypress event on mac\n    if (CodeMirror.isMac && e.altKey && !e.metaKey && !e.ctrlKey) {\n      name = name.slice(2);\n    }\n    if ((name || key.length > 1) && e.shiftKey) { name += 'S-'; }\n\n    if (vim && !vim.expectLiteralNext && key.length == 1) {\n      if (langmap.keymap && key in langmap.keymap) {\n        if (langmap.remapCtrl != false || !name)\n          key = langmap.keymap[key];\n      } else if (key.charCodeAt(0) > 255) {\n        var code = e.code?.slice(-1) || \"\";\n        if (!e.shiftKey) code = code.toLowerCase();\n        if (code) key = code;\n      }\n    }\n\n    name += key;\n    if (name.length > 1) { name = '<' + name + '>'; }\n    return name;\n  }\n  // langmap support\n  function updateLangmap(langmapString, remapCtrl) {\n    if (langmap.string !== langmapString) {\n      langmap = parseLangmap(langmapString);\n    }\n    langmap.remapCtrl = remapCtrl;\n  }\n  /** \n   *  From :help langmap\n   *  The 'langmap' option is a list of parts, separated with commas.  Each\n   *      part can be in one of two forms:\n   *      1.  A list of pairs.  Each pair is a \"from\" character immediately\n   *          followed by the \"to\" character.  Examples: \"aA\", \"aAbBcC\".\n   *      2.  A list of \"from\" characters, a semi-colon and a list of \"to\"\n   *          characters.  Example: \"abc;ABC\"\n   * @arg {string} langmapString\n   * @returns {{string: string, keymap: Record<string, string>, remapCtrl?: boolean}}\n   */\n  function parseLangmap(langmapString) {\n    let keymap = ({})/**@type {Record<string, string>}*/;\n    if (!langmapString) return { keymap: keymap, string: '' };\n\n    function getEscaped(list) {\n      return list.split(/\\\\?(.)/).filter(Boolean);\n    }\n    langmapString.split(/((?:[^\\\\,]|\\\\.)+),/).map(part => {\n      if (!part) return;\n      const semicolon = part.split(/((?:[^\\\\;]|\\\\.)+);/);\n      if (semicolon.length == 3) {\n        const from = getEscaped(semicolon[1]);\n        const to = getEscaped(semicolon[2]);\n        if (from.length !== to.length) return; // skip over malformed part\n        for (let i = 0; i < from.length; ++i) keymap[from[i]] = to[i];\n      } else if (semicolon.length == 1) {\n        const pairs = getEscaped(part);\n        if (pairs.length % 2 !== 0) return; // skip over malformed part\n        for (let i = 0; i < pairs.length; i += 2) keymap[pairs[i]] = pairs[i + 1];\n      }\n    });\n\n    return { keymap: keymap, string: langmapString };\n  }\n\n  defineOption('langmap', undefined, 'string', ['lmap'], function(name, cm) {\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      return langmap.string;\n    } else {\n      updateLangmap(name);\n    }\n  });\n\n  // Represents the current input state.\n  class InputState {\n    constructor() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n      this.changeQueue = null; // For restoring text used by insert mode keybindings\n    }\n    pushRepeatDigit(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    }\n    getRepeat() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    }\n  }\n\n  /** @arg {CodeMirrorV} cm  @arg {string} [reason] */\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    cm.state.vim.expectLiteralNext = false;\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n\n  function ChangeQueue() {\n    this.removed = [];\n    this.inserted = \"\";\n  }\n\n  /**\n   * Register stores information about copy and paste registers.  Besides\n   * text, a register must store whether it is linewise (i.e., when it is\n   * pasted, should it insert itself into a new line, or should the text be\n   * inserted at the cursor position.)\n   */\n  class Register {\n    constructor(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    setText(text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    pushText(text, linewise) {\n      // if this register has ever been set to linewise, use linewise.\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    }\n    pushInsertModeChanges(changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    }\n    pushSearchQuery(query) {\n      this.searchQueries.push(query);\n    }\n    clear() {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    }\n    toString() {\n      return this.keyBuffer.join('');\n    }\n  }\n\n  /**\n   * Defines an external register.\n   *\n   * The name should be a single character that will be used to reference the register.\n   * The register should support setText, pushText, clear, and toString(). See Register\n   * for a reference implementation.\n   * @arg {string} name\n   * @arg {Register} register\n   */\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n    if (registers[name]) {\n      throw Error('Register already defined ' + name);\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  /**\n   * vim registers allow you to keep many independent copy and paste buffers.\n   * See http://usevim.com/2012/04/13/registers/ for an introduction.\n   *\n   * RegisterController keeps the state of all the registers.  An initial\n   * state may be passed in.  The unnamed register '\"' will always be\n   * overridden.\n   */\n  class RegisterController {\n    /** @arg {Object<string, Register>} registers */\n    constructor(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n      registers['+'] = new Register();\n    }\n    pushText(registerName, operator, text, linewise, blockwise) {\n      // The black hole register, \"_, means delete/yank to nowhere.\n      if (registerName === '_') return;\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n      // Lowercase and uppercase registers refer to the same register.\n      // Uppercase just means append.\n      var register = this.isValidRegister(registerName) ?\n          this.getRegister(registerName) : null;\n      // if no register/an invalid register was specified, things go to the\n      // default registers\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            // The 0 register contains the text from the most recent yank.\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              // Delete less than 1 line. Update the small delete register.\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              // Shift down the contents of the numbered registers and put the\n              // deleted text into register 1.\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n            break;\n        }\n        // Make sure the unnamed register is set to what just happened\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      // If we've gotten to this point, we've actually specified a register\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      if (registerName === '+') {\n        navigator.clipboard.writeText(text);\n      }\n      // The unnamed register always has the same value as the last used\n      // register.\n      this.unnamedRegister.setText(register.toString(), linewise);\n    }\n    /**\n     * Gets the register named @name.  If one of @name doesn't already exist,\n     * create it.  If @name is invalid, return the unnamedRegister.\n     * @arg {string} [name]\n     */\n    getRegister(name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    }\n    /**@type {{(name: any): name is string}} */\n    isValidRegister(name) {\n      return name && (inArray(name, validRegisters) || latinCharRegex.test(name));\n    }\n    shiftNumericRegisters_() {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  }\n  class HistoryController {\n    constructor() {\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n    // the input argument here acts a user entered prefix for a small time\n    // until we start autocompletion in which case it is the autocompleted.\n    nextMatch(input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      // should return the user input in case we reach the end of buffer.\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      // return the last autocompleted query or exCommand as it is.\n      if (i < 0) return input;\n    }\n    pushInput(input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    }\n    reset() {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  }\n  var commandDispatcher = {\n    matchCommand: function(keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return {type: 'none'};\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial',\n          expectLiteralNext: matches.partial.length == 1 && matches.partial[0].keys.slice(-11) == '<character>' // langmap literal logic\n        };\n      }\n\n      var bestMatch;\n      // @ts-ignore\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == '<character>' || bestMatch.keys.slice(-10) == '<register>') {\n        var character = lastChar(keys);\n        if (!character || character.length > 1) return {type: 'clear'};\n        inputState.selectedCharacter = character;\n      }\n      return {type: 'full', command: bestMatch};\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {vimKey} command\n     */\n    processCommand: function(cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").motionCommand|import(\"./types\").operatorMotionCommand} command\n     */\n    processMotion: function(cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = /**@type {MotionArgs}*/(copyArgs(command.motionArgs));\n      this.evalInput(cm, vim);\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").operatorCommand|import(\"./types\").operatorMotionCommand} command\n     */\n    processOperator: function(cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          // Typing an operator twice like 'dd' makes the operator operate\n          // linewise\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = { linewise: true, repeat: 1 };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          // 2 different operators in a row doesn't make sense.\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n          vim.visualBlock = false;\n          updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        // Operating on a selection in visual mode. We don't need a motion.\n        this.evalInput(cm, vim);\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").operatorMotionCommand} command\n     */\n    processOperatorMotion: function(cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        // Operator motions may have special behavior in visual mode.\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").actionCommand} command\n     */\n    processAction: function(cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = /**@type {ActionArgs}*/(copyArgs(command.actionArgs) || {repeat: 1});\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      // Actions may or may not have motions and operators. Do these first.\n      if (command.operator) {\n        // @ts-ignore\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        // @ts-ignore\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    /** @arg {CodeMirrorV} cm @arg {vimState} vim @arg {import(\"./types\").searchCommand} command*/\n    processSearch: function(cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        // Search depends on SearchCursor.\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = (forward) ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      /** @arg {string} query  @arg {boolean} ignoreCase  @arg {boolean} smartCase */\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          keys: '',\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n        });\n      }\n      /** @arg {string} query */\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      /** \n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e \n       * @arg {any} query \n       * @arg {(arg0: any) => void} close \n       */\n      function onPromptKeyUp(e, query, close) {\n        var keyName = vimKeyFromEvent(e), up, offset;\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n          vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(cm, query,\n              true /** ignoreCase */, true /** smartCase */);\n        } catch (e) {\n          // Swallow bad regexes for incremental search.\n        }\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      /** @arg {KeyboardEvent} e  @arg {string} query  @arg {(arg0?: string) => void} close */\n      function onPromptKeyDown(e, query, close) {\n        var keyName = vimKeyFromEvent(e);\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n            (keyName == '<BS>' && query == '')) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == '<C-u>') {\n          // Ctrl-U clears input.\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            let query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: '(JavaScript regexp)',\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n            });\n          }\n          break;\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, {noSymbol: true});\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(cm, {noSymbol: false});\n            isKeyword = false;\n          }\n          if (!word) {\n            showConfirm(cm, 'No word under cursor');\n            clearInputState(cm);\n            return;\n          }\n          let query = cm.getLine(word.start.line).substring(word.start.ch,\n              word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n\n          // cachedCursor is used to save the old position of the cursor\n          // when * or # causes vim to seek for the nearest word and shift\n          // the cursor before entering the motion.\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    /**\n     * @arg {CodeMirrorV} cm\n     * @arg {vimState} vim\n     * @arg {import(\"./types\").exCommand | import(\"./types\").keyToExCommand} command\n     */\n    processEx: function(cm, vim, command) {\n      /**@arg {string} input*/\n      function onPromptClose(input) {\n        // Give the prompt some time to close so that if processCommand shows\n        // an error, the elements don't overlap.\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n        if (cm.state.vim) clearInputState(cm);\n      }\n      /**\n       * @arg {KeyboardEvent&{target:HTMLInputElement}} e\n       * @arg {string} input\n       * @arg {(arg0?: string) => void} close\n       */\n      function onPromptKeyDown(e, input, close) {\n        var keyName = vimKeyFromEvent(e), up, offset;\n        if (keyName == '<Esc>' || keyName == '<C-c>' || keyName == '<C-[>' ||\n            (keyName == '<BS>' && input == '')) {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == '<Up>' || keyName == '<Down>') {\n          CodeMirror.e_stop(e);\n          up = keyName == '<Up>' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == '<C-u>') {\n          // Ctrl-U clears input.\n          CodeMirror.e_stop(e);\n          close('');\n        } else if (keyName && keyName != '<Left>' && keyName != '<Right>') {\n            vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == 'keyToEx') {\n        // Handle user defined Ex to Ex mappings\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n              onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n        } else {\n          showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n              onKeyDown: onPromptKeyDown});\n        }\n      }\n    },\n    /**@arg {CodeMirrorV} cm   @arg {vimState} vim */\n    evalInput: function(cm, vim) {\n      // If the motion command is set, execute both the operator and motion.\n      // Otherwise return.\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      /** @type {MotionArgs}*/\n      var motionArgs = inputState.motionArgs || { repeat: 1};\n      var operator = inputState.operator;\n      /** @type {OperatorArgs}*/\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      // TODO: Make sure cm and vim selections are identical outside visual mode.\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        // If repeatOverride is specified, that takes precedence over the\n        // input state's repeat. Used by Ex mode and can be user defined.\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat ||\n          (!motionArgs.explicitRepeat && repeat === 0)) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        // If there is a character input, stick it in all of the arg arrays.\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n            inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          var jumpList = vimGlobalState.jumpList;\n          // if the current motion is # or *, use cachedCursor\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            // @ts-ignore\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            // @ts-ignore\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        // TODO: Handle null returns from motion commands better.\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, oldHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<',\n              cursorIsBefore(newAnchor, newHead) ? newAnchor\n                  : newHead);\n          updateMark(cm, vim, '>',\n              cursorIsBefore(newAnchor, newHead) ? newHead\n                  : newAnchor);\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead, oldHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          // Replaying a visual mode operation\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            // Linewise Visual mode: The same number of lines.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            // Blockwise Visual mode: The same number of lines and columns.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            // Normal Visual mode within one line: The same number of characters.\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            // Normal Visual mode with several lines: The same number of lines, in the\n            // last line the same number of characters as in the last line the last time.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n        var curStart, curEnd, linewise;\n        /** @type {'block'|'line'|'char'}*/ var mode;\n        var cmSel;\n        if (vim.visualMode) {\n          // Init visual op\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' :\n                  linewise ? 'line' :\n                  'char';\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode);\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == 'block') {\n              // Linewise operators in visual block mode extend to end of line\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          // Init motion op\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n          cmSel = makeCmSelection(cm, {\n            anchor: newPositions.start,\n            head: newPositions.end\n          }, mode, exclusive);\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        // Keep track of linewise as it affects how paste and change behave.\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](\n          cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    /**@arg {vimState} vim  @arg {InputStateInterface} inputState, @arg {import(\"./types\").actionCommand} [actionCommand] */\n    recordLastEdit: function(vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) { return; }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n\n  /**\n   * All of the functions below return Cursor objects.\n   * @type {import(\"./types\").vimMotions}}\n   */\n  var motions = {\n    moveToTopLine: function(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function(cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function(cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function(_cm, head, motionArgs) {\n      // Expands forward to end of line, and then to next line if repeat is\n      // >1. Does not handle backward motion!\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function(cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      // If search is initiated with ? instead of /, negate direction.\n      prev = (state.isReversed()) ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n    },\n    /**\n     * Find and select the next occurrence of the search query. If the cursor is currently\n     * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n     * appropriate direction.\n     *\n     * This differs from `findNext` in the following ways:\n     *\n     * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n     * 2. If the cursor is currently inside a search match, this selects the current match\n     *    instead of the next match.\n     * 3. If there is no associated operator, this will turn on visual mode.\n     */\n    findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = (state.isReversed()) ? !prev : prev;\n\n      // next: [from, to] | null\n      var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n      // No matches.\n      if (!next) {\n        return;\n      }\n\n      // If there's an operator that will be executed, return the selection.\n      if (prevInputState.operator) {\n        return next;\n      }\n\n      // At this point, we know that there is no accompanying operator -- let's\n      // deal with visual mode in order to select an appropriate match.\n\n      var from = next[0];\n      // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n      // the resulting selection is extended by 1 char. Let's shrink it so that only the\n      // match is selected.\n      var to = new Pos(next[1].line, next[1].ch - 1);\n\n      if (vim.visualMode) {\n        // If we were in visualLine or visualBlock mode, get out of it.\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        // If we're currently in visual mode, we should extend the selection to include\n        // the search result.\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n\n            return [anchor, from];\n          }\n        }\n      } else {\n        // Let's turn visual mode on.\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n      }\n\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function(cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter || \"\");\n      if (pos) {\n        return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [\n          clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n          clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n        ];\n      } else {\n        return ([vim.sel.head, vim.sel.anchor]);\n      }\n    },\n    jumpToMark: function(cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = (motionArgs.forward) ?\n            // @ts-ignore\n            cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n          if (isWrongDirection) {\n            continue;\n          }\n          // @ts-ignore\n          if (motionArgs.linewise && (mark.line == cursor.line)) {\n            continue;\n          }\n\n          var equal = cursorEqual(cursor, best);\n          var between = (motionArgs.forward) ?\n            // @ts-ignore\n            cursorIsBetween(cursor, mark, best) :\n            // @ts-ignore\n            cursorIsBetween(best, mark, cursor);\n\n          if (equal || between) {\n            // @ts-ignore\n            best = mark;\n          }\n        }\n      }\n\n      if (motionArgs.linewise) {\n        // Vim places the cursor on the first non-whitespace character of\n        // the line if there is one, else it places the cursor at the end\n        // of the line, regardless of whether a mark was found.\n        best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n      return best;\n    },\n    moveByCharacters: function(_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function(cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      // Depending what our last motion was, we may want to do different\n      // things. If our last motion was moving vertically, we want to\n      // preserve the HPos from our last horizontal move.  If our last motion\n      // was going to the end of a line, moving vertically we should go to\n      // the end of the line, etc.\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n      var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n      if (hasMarkedText) {\n        line = posV.line;\n        endCh = posV.ch;\n      }\n      // Vim go to line begin or line end when cursor at first/last line and\n      // move to previous/next line is triggered.\n      if (line < first && cur.line == first){\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last){\n          return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      if (motionArgs.toFirstChar){\n        endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function(cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur,'div').left;\n      }\n      var repeat = motionArgs.repeat;\n      var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n          res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function(cm, head, motionArgs) {\n      // CodeMirror only exposes functions that move the cursor page down, so\n      // doing this bad hack to move the cursor and move it back. evalInput\n      // will move the cursor to where it should be in the end.\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n    },\n    moveByParagraph: function(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir).start;\n    },\n    moveBySentence: function(cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function(cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function(cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n          !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n          motionArgs.selectedCharacter, head);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward,\n          motionArgs.selectedCharacter, head) || head;\n    },\n    moveToSymbol: function(cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return motionArgs.selectedCharacter\n       && findSymbol(cm, repeat, motionArgs.forward,\n          motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function(cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      // repeat is equivalent to which column we want to move to!\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head,'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function(cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n      // Go to the start of the line where the text begins, or the end for\n      // whitespace-only lines\n      var cursor = head;\n      return new Pos(cursor.line,\n                  findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function(cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n      if (ch < lineText.length) {\n        // Only include angle brackets in analysis if they are being matched.\n        var re = (symbol === '<' || symbol === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n        var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function(_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n      return new Pos(lineNum,\n                  findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    moveToStartOfDisplayLine: function(cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function(cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function(cm, head, motionArgs, vim) {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n      /** @type{Object<string, string>} */\n      var mirroredPairs = {'(': ')', ')': '(',\n                            '{': '}', '}': '{',\n                            '[': ']', ']': '[',\n                            '<': '>', '>': '<'};\n      /** @type{Object<string, boolean>} */\n      var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n      var character = motionArgs.selectedCharacter || \"\";\n      // 'b' refers to  '()' block.\n      // 'B' refers to  '{}' block.\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n\n      // Inclusive is the difference between a and i\n      // TODO: Instead of using the additional text object map to perform text\n      //     object operations, merge the map into the defaultKeyMap and use\n      //     motionArgs to define behavior. Define separate entries for 'aw',\n      //     'iw', 'a[', 'i[', etc.\n      var inclusive = !motionArgs.textObjectInner;\n\n      var tmp, move;\n      if (mirroredPairs[character]) {\n        move = true;\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n        if (!tmp) {\n          var sc = cm.getSearchCursor(new RegExp(\"\\\\\" + character, \"g\"), head);\n          if (sc.find()) {\n            // @ts-ignore\n            tmp = selectCompanionObject(cm, sc.from(), character, inclusive);\n          }\n        }\n      } else if (selfPaired[character]) {\n        move = true;\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W' || character === 'w') {\n        var repeat = motionArgs.repeat || 1;\n        while (repeat-- > 0) {\n          var repeated = expandWordUnderCursor(cm, {\n            inclusive,\n            innerWord: !inclusive,\n            bigWord: character === 'W',\n            noSymbol: character === 'W',\n            multiline: true\n          }, tmp && tmp.end);\n          if (repeated) {\n            if (!tmp) tmp = repeated;\n            tmp.end = repeated.end;\n          }\n        }\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) { vim.visualLine = true; }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) { operatorArgs.linewise = true; }\n          tmp.end.line--;\n        }\n      } else if (character === 't') {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else if (character === 's') {\n        // account for cursor on end of sentence symbol\n        var content = cm.getLine(head.line);\n        if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n          head.ch -= 1;\n        }\n        var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n        var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n        // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n        if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n            && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n          start = {line: start.line, ch: start.ch + 1};\n        }\n        tmp = {start: start, end: end};\n      }\n\n      if (!tmp) {\n        // No valid text object, don't move.\n        return null;\n      }\n\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end, move);\n      }\n    },\n\n    repeatLastCharacterSearch: function(cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n\n  /** @arg {string} name  @arg {import(\"./types\").MotionFn} fn */\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  /** @arg {string} val @arg {number} times */\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  /**\n   * An operator acts on a text selection. It receives the list of selections\n   * as input. The corresponding CodeMirror selection is guaranteed to\n   * match the input selection.\n   */\n  /** @type {import(\"./types\").vimOperators} */\n  var operators = {\n    change: function(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState;\n        if (lastState?.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var match = (/\\s+$/).exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, - match[0].length);\n            text = text.slice(0, - match[0].length);\n          }\n        }\n        if (args.linewise) {\n          anchor = new Pos(anchor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(anchor.line)));\n          if (head.line > anchor.line) {\n            head = new Pos(head.line - 1, Number.MAX_VALUE);\n          }\n        }\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n      } else if (args.fullLine) {\n          head.ch = Number.MAX_VALUE;\n          head.line--;\n          cm.setSelection(anchor, head);\n          text = cm.getSelection();\n          cm.replaceSelection(\"\");\n          finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(\n          args.registerName, 'change', text,\n          args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n    },\n    delete: function(cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (args.linewise &&\n            head.line != cm.firstLine() &&\n            anchor.line == cm.lastLine() &&\n            anchor.line == head.line - 1) {\n          // Special case for dd on last line (and first line).\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(\n          args.registerName, 'delete', text,\n          args.linewise, vim.visualBlock);\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function(cm, args, ranges) {\n      var vim = cm.state.vim;\n      var repeat = (vim.visualMode) ? (args.repeat || 0) : 1;\n      if (cm.indentMore) {\n        for (var j = 0; j < repeat; j++) {\n          if (args.indentRight) cm.indentMore();\n          else cm.indentLess();\n        }\n      } else {\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n      }\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function(cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    hardWrap: function(cm, operatorArgs, ranges, oldAnchor) {\n      if (!cm.hardWrap) return;\n      var from = ranges[0].anchor.line;\n      var to = ranges[0].head.line;\n      if (operatorArgs.linewise) to--;\n      var endRow = cm.hardWrap({from: from, to: to});\n      if (endRow > from && operatorArgs.linewise) endRow--;\n      return operatorArgs.keepCursor ? oldAnchor : new Pos(endRow, 0);\n    },\n    changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() :\n                character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor){\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise){\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function(cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode\n        ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n        : oldAnchor;\n      vimGlobalState.registerController.pushText(\n          args.registerName, 'yank',\n          text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n\n  /** @arg {string} name  @arg {import(\"./types\").OperatorFn} fn */\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  /** @type {import(\"./types\").vimActions} */\n  var actions = {\n    jumpListWalk: function(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n    },\n    scroll: function(cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight;\n            cursor.line = Math.ceil(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.top);\n        } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n            cursor.line = Math.floor(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(\n                null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function(cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      switch (actionArgs.position) {\n        case 'center': y = charCoords.bottom - height / 2;\n          break;\n        case 'bottom':\n          var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n          var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n          var lineHeight = lineLastCharCoords.bottom - y;\n          y = y - height + lineHeight;\n          break;\n      }\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter || \"\";\n      var repeat = actionArgs.repeat || 1;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while(repeat--){\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function(cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function(cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n      }\n    },\n    enterInsertMode: function(cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) { return; }\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n      if (insertAt == 'eol') {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, offsetCursor(head, 0, 1));\n        head = newPosition.end;\n      } else if (insertAt == 'firstNonBlank') {\n        var newPosition = updateSelectionForSurrogateCharacters(cm, head, motions.moveToFirstNonWhiteSpaceCharacter(cm, head));\n        head = newPosition.end;\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode)\n            return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(\n              Math.min(sel.head.line, sel.anchor.line),\n              Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualMode)\n            return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(\n              Math.min(sel.head.line, sel.anchor.line),\n              Math.max(sel.head.ch, sel.anchor.ch) + 1);\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode){\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption('disableInput', false);\n      if (actionArgs && actionArgs.replace) {\n        // Handle Replace-mode as a special case of insert mode.\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        // Only record if not replaying.\n        cm.on('change', onChange);\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(head, {insertLeft: true});\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function(cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      // TODO: The repeat should actually select number of characters/lines\n      //     equal to the repeat times the size of the previous visual\n      //     operation.\n      if (!vim.visualMode) {\n        // Entering visual mode\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(\n            cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n        var newPosition = updateSelectionForSurrogateCharacters(cm, anchor, head);\n        vim.sel = {\n          anchor: newPosition.start,\n          head: newPosition.end\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine != !!actionArgs.linewise ||\n          vim.visualBlock != !!actionArgs.blockwise) {\n        // Toggling between modes\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function(cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          // If the marks have been destroyed due to edits, do nothing.\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' :\n                    vim.visualBlock ? 'blockwise' : ''});\n      }\n    },\n    joinLines: function(cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        // Repeat is the number of lines to join. Minimum 2 lines.\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                              Infinity));\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var text = '';\n        var nextStartCh = 0;\n        if (!actionArgs.keepSpaces) {\n          var nextLine = cm.getLine(curStart.line + 1);\n          nextStartCh = nextLine.search(/\\S/);\n          if (nextStartCh == -1) {\n            nextStartCh = nextLine.length;\n          } else {\n            text = \" \";\n          }\n        }\n        cm.replaceRange(text, \n          new Pos(curStart.line, finalCh),\n          new Pos(curStart.line + 1, nextStartCh));\n      }\n      var curFinalPos = clipCursorToContent(cm, new Pos(curStart.line, finalCh));\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        // Special case for inserting newline before start of document.\n        cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = (actionArgs.after) ? insertAt.line :\n            insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n            CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function(cm, actionArgs, vim) {\n      var register = vimGlobalState.registerController.getRegister(\n          actionArgs.registerName);\n      if (actionArgs.registerName === '+') {\n        navigator.clipboard.readText().then((value) => {\n          this.continuePaste(cm, actionArgs, vim, value, register);\n        });\n      } else {\n        var text = register.toString();\n        this.continuePaste(cm, actionArgs, vim, text, register);\n      }\n    },\n    continuePaste: function(cm, actionArgs, vim, text, register) {\n      var cur = copyCursor(cm.getCursor());\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        // length that considers tabs and tabSize\n        var whitespaceLength = function(/** @type {string} */ str) {\n          var tabs = (str.split(\"\\t\").length - 1);\n          var spaces = (str.split(\" \").length - 1);\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        // @ts-ignore\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        // chomp last newline b/c don't want it to match /^\\s*/gm\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        // @ts-ignore\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          }\n          else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          }\n          else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        // @ts-ignore\n        text = text.split('\\n');\n        if (linewise) {\n          // @ts-ignore\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          // @ts-ignore\n          text[i] = (text[i] == '') ? ' ' : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if(vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          // Move the newline at the end to the start instead, and paste just\n          // before the newline character of the line we are on right now.\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      if (vim.visualMode) {\n        //  save the pasted text for reselection if the need arises\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n        // save the curEnd marker before it get cleared due to cm.replaceRange.\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        // push the previously selected text to unnamed register\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          // first delete the selected text\n          cm.replaceSelections(emptyStrings);\n          // Set new selections as per the block length of the yanked text\n          selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          // @ts-ignore\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n        // restore the curEnd marker\n        if(lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch=0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line+i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n',  new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n          // @ts-ignore\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          // Now fine tune the cursor to where we want it.\n          if (linewise) {\n            var line = actionArgs.after ? cur.line + 1 : cur.line;\n            curPosFinal = new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n          } else {\n            curPosFinal = copyCursor(cur);\n            if (!/\\n/.test(text)) {\n              curPosFinal.ch += text.length - (actionArgs.after ? 1 : 0);\n            }\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function(cm, actionArgs) {\n      cm.operation(function() {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(clipCursorToContent(cm, cm.getCursor('start')));\n      });\n    },\n    redo: function(cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function(_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    insertRegister: function(cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      var text = register && register.toString();\n      if (text) {\n        cm.replaceSelection(text);\n      }\n    },\n    oneNormalCommand: function(cm, actionArgs, vim) {\n      exitInsertMode(cm, true);\n      vim.insertModeReturn = true;\n      CodeMirror.on(cm, 'vim-command-done', function handler() {\n        if (vim.visualMode) return;\n        if (vim.insertModeReturn) {\n          vim.insertModeReturn = false;\n          if (!vim.insertMode) {\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        }\n        CodeMirror.off(cm, 'vim-command-done', handler);\n      });\n    },\n    setMark: function(cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      if (markName) updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function(cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter || \"\";\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo=line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n\n      var newPositions = updateSelectionForSurrogateCharacters(cm, curStart, curEnd);\n      curStart = newPositions.start;\n      curEnd = newPositions.end;\n      if (replaceWith=='\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        // special case, where vim help says to replace by just one line-break\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        // replace all surrogate characters with selected character\n        replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n        //replace all characters in range by selected, but keep linebreaks\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          // Tabs are split in visua block before replacing\n          var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, replaceWith);\n          var replaceWithStrings = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStrings);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                        selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function(cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end)break;\n      }\n      // @ts-ignore\n      if (!actionArgs.backtrack && (end <= cur.ch))return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        // @ts-ignore\n        var from = new Pos(cur.line, start);\n        // @ts-ignore\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      // @ts-ignore\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function(cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) { return; }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function(cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: function(cm, actionArgs) {\n      exitInsertMode(cm);\n    }\n  };\n\n  /** @arg {string } name  @arg {import(\"./types\").ActionFn} fn */\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  /*\n    * Below are miscellaneous utility functions used by vim.js\n    */\n\n  /**\n   * Clips cursor to ensure that line is within the buffer's range\n   * and is not inside surrogate pair\n   * If includeLineBreak is true, then allow cur.ch == lineLength.\n   * @arg {CodeMirrorV} cm \n   * @arg {Pos} cur \n   * @arg {Pos} [oldCur]\n   * @return {Pos}\n   */\n  function clipCursorToContent(cm, cur, oldCur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n    var text = cm.getLine(line);\n    var maxCh = text.length - 1 + Number(!!includeLineBreak);\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    // prevent cursor from entering surrogate pair\n    var charCode = text.charCodeAt(ch);\n    if (0xDC00 <= charCode && charCode <= 0xDFFF) {\n      var direction = 1;\n      if (oldCur && oldCur.line == line && oldCur.ch > ch) {\n        direction = -1;\n      }\n      ch +=direction;\n      if (ch > maxCh) ch -=2;\n    }\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    // Partial matches are not applied. They inform the key handler\n    // that the current key sequence is a subsequence of a valid key\n    // sequence, so that the key buffer is not cleared.\n    if (inputState.operator) context = \"operatorPending\";\n    var match, partial = [], full = [];\n    // if currently expanded key comes from a noremap, searcg only in default keys\n    var startIndex = noremap ? keyMap.length - defaultKeymapLength : 0;\n    for (var i = startIndex; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (context == 'insert' && command.context != 'insert' ||\n          (command.context && command.context != context) ||\n          inputState.operator && command.type == 'action' ||\n          !(match = commandMatch(keys, command.keys))) { continue; }\n      if (match == 'partial') { partial.push(command); }\n      if (match == 'full') { full.push(command); }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n  /** @arg {string} pressed  @arg {string} mapped  @return {'full'|'partial'|false}*/\n  function commandMatch(pressed, mapped) {\n    const isLastCharacter = mapped.slice(-11) == '<character>';\n    const isLastRegister = mapped.slice(-10) == '<register>';\n    if (isLastCharacter || isLastRegister) {\n      // Last character matches anything.\n      var prefixLen = mapped.length - (isLastCharacter ? 11 : 10);\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n              mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' :\n              mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n  /** @arg {string} keys */\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1){\n      switch(selectedCharacter){\n        case '<CR>':\n        case '<S-CR>':\n          selectedCharacter='\\n';\n          break;\n        case '<Space>':\n        case '<S-Space>':\n          selectedCharacter=' ';\n          break;\n        default:\n          selectedCharacter='';\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  /** @arg {CodeMirror} cm   @arg {{ (cm: CodeMirror): void }} fn   @arg {number} repeat */\n  function repeatFn(cm, fn, repeat) {\n    return function() {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  /** @arg {Pos} cur   @return {Pos}*/\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  /** @arg {Pos} cur1 @arg {Pos} cur2  @return {boolean} */\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  /** @arg {Pos} cur1  @arg {Pos} cur2 @return {boolean}*/\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  /** @arg {Pos} cur1 @arg {Pos} cur2  @return {Pos}*/\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      // @ts-ignore\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  /** @arg {Pos} cur1  @arg {Pos} cur2  @return {Pos} */\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      // @ts-ignore\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  /** @arg {Pos} cur1   @arg {Pos} cur2  @arg {Pos} cur3  @return {boolean}*/ \n  function cursorIsBetween(cur1, cur2, cur3) {\n    // returns true if cur2 is between cur1 and cur3.\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  /** @arg {CodeMirror} cm  @arg {number} lineNum */\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  /** @arg {string} s */\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n  /** @arg {string} s */\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n  /** @arg {CodeMirror} cm  @arg {number} lineNum  @arg {number} column */\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column-endCh+1).join(' ');\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  // This functions selects a rectangular block\n  // of text with selectionEnd as any of its corner\n  // Height of block:\n  // Difference in selectionEnd.line and first/last selection.line\n  // Width of the block:\n  // Distance between selectionEnd.ch and any(first considered here) selection.ch\n  /** @arg {CodeMirror} cm  @arg {Pos} selectionEnd */\n  function selectBlock(cm, selectionEnd) {\n    var selections = [], ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch, headCh = head.ch;\n\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) { headCh--; }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) { headCh++; }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  /** @arg {CodeMirror} cm  @arg {any} head  @arg {number} height */\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({anchor: lineHead, head: lineHead});\n    }\n    cm.setSelections(sel, 0);\n  }\n  // getIndex returns the index of the cursor in the selections.\n  /** @arg {string | any[]} ranges  @arg {any} cursor  @arg {string | undefined} [end] */\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  /** @arg {CodeMirror} cm  @arg {vimState} vim */\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    /** @return {[Pos,Pos]} */\n    var getCurrentSelectedAreaRange = function() {\n      var selections = cm.listSelections();\n      var start =  selections[0];\n      var end = selections[selections.length-1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function() {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n        // selectBlock creates a 'proper' rectangular block.\n        // We do not want that in all cases, so we manually set selections.\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = {anchor: anchor, head: head};\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n    // In case of replaying the action.\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  // Updates the previous selection with the current selection's values. This\n  // should only be called in visual mode.\n  /** @arg {CodeMirror} cm @arg {vimState} vim */\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    // To accommodate the effect of lastPastedText in the last selection\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                          'headMark': cm.setBookmark(head),\n                          'anchor': copyCursor(anchor),\n                          'head': copyCursor(head),\n                          'visualMode': vim.visualMode,\n                          'visualLine': vim.visualLine,\n                          'visualBlock': vim.visualBlock};\n  }\n  /** @arg {CodeMirrorV} cm @arg {Pos} start @arg {Pos} end @returns {[Pos, Pos]} */\n  function expandSelection(cm, start, end, move) {\n    var sel = cm.state.vim.sel;\n    var head = move ? start: sel.head;\n    var anchor = move ? start: sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  /**\n   * Updates the CodeMirror selection to match the provided vim selection.\n   * If no arguments are given, it uses the current vim selection state.\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState[\"sel\"]} [sel] \n   * @arg {\"char\"|\"line\"|\"block\" | undefined} [mode]\n   */\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    if (!mode) {\n      mode = vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    }\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {import(\"./types\").CM5RangeInterface} sel\n   * @arg {\"char\"|\"line\"|\"block\"} mode \n   * @arg {boolean|undefined} [exclusive] \n   * @return {{ranges: any, primary: number}}\n   */\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{anchor: anchor, head: head}],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{anchor: anchor, head: head}],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n          fromCh = anchor.ch,\n          bottom = Math.max(anchor.line, head.line),\n          toCh = head.ch;\n      if (fromCh < toCh) { toCh += 1; }\n      else { fromCh += 1; }      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh)\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n    throw \"never happens\";\n  }\n  /** @arg {CodeMirror} cm */\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n    if (cm.getSelection().length == 1) {\n      // Small corner case when only 1 character is selected. The \"real\"\n      // head is the left of head and anchor.\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n    return cur;\n  }\n\n  /**\n   * If moveHead is set to false, the CodeMirror selection will not be\n   * touched. The caller assumes the responsibility of putting the cursor\n   * in the right place.\n   * @arg {CodeMirrorV} cm \n   * @arg {boolean} [moveHead]\n   */\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n  }\n\n  /** \n   * Remove any trailing newlines from the selection. For\n   * example, with the caret at the start of the last word on the line,\n   * 'dw' should word, but not the newline, while 'w' should advance the\n   * caret to the first character of the next line.\n   * @arg {CodeMirror} cm\n   * @arg {Pos} curStart\n   * @arg {Pos} curEnd\n   */\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    // Only clip if the selection ends with trailing newline + whitespace\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      // We know this is all whitespace.\n      lines.pop();\n\n      // Cases:\n      // 1. Last word is an empty line - do not clip the trailing '\\n'\n      // 2. Last word is not an empty line - clip the trailing '\\n'\n      // Find the line containing the last word, and clip all whitespace up\n      // to it.\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      // If the last word is not an empty line, clip an additional newline\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  // Expand the selection to line ends.\n  /** @arg {CodeMirror} _cm  @arg {Pos} curStart  @arg {Pos} curEnd */\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  /** @arg {string} [text] */\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  /** \n   * @arg {CodeMirror} cm \n   * @arg {{inclusive?: boolean, innerWord?: boolean, bigWord?: boolean, noSymbol?: boolean, multiline?: boolean}} options\n   * @arg {Pos} [cursor]\n   **/\n  function expandWordUnderCursor(cm, {inclusive, innerWord, bigWord, noSymbol, multiline}, cursor) {\n    var cur = cursor || getHead(cm);\n    var line = cm.getLine(cur.line);\n    var endLine = line;\n    var startLineNumber = cur.line;\n    var endLineNumber = startLineNumber;\n    var idx = cur.ch;\n\n    var wordOnNextLine;\n    // Seek to first word or non-whitespace character, depending on if\n    // noSymbol is true.\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n    if (innerWord && /\\s/.test(line.charAt(idx))) {\n      test = function(/** @type {string} */ ch) { return /\\s/.test(ch); };\n    } else {\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n          if (!multiline) return null;\n          idx--;\n          wordOnNextLine = findWord(cm, cur, true, bigWord, true);\n          break\n        }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n    }\n\n    var end = idx, start = idx;\n    while (test(line.charAt(start)) && start >= 0) { start--; }\n    start++;\n    if (wordOnNextLine) {\n      end = wordOnNextLine.to;\n      endLineNumber = wordOnNextLine.line;\n      endLine = cm.getLine(endLineNumber);\n      if (!endLine && end == 0) end++;\n    } else {\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n    }\n\n    if (inclusive) {\n      // If present, include all whitespace after word.\n      // Otherwise, include all whitespace before word, except indentation.\n      var wordEnd = end;\n      var startsWithSpace = cur.ch <= start && /\\s/.test(line.charAt(cur.ch));\n      if (!startsWithSpace) {\n        while (/\\s/.test(endLine.charAt(end)) && end < endLine.length) { end++; }\n      }\n      if (wordEnd == end || startsWithSpace) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n        if (!start && !startsWithSpace) { start = wordStart; }\n      }\n    }\n\n    return { start: new Pos(startLineNumber, start), end: new Pos(endLineNumber, end) };\n  }\n\n  /**\n   * Depends on the following:\n   *\n   * - editor mode should be htmlmixedmode / xml\n   * - mode/xml/xml.js should be loaded\n   * - addon/fold/xml-fold.js should be loaded\n   *\n   * If any of the above requirements are not true, this function noops.\n   *\n   * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n   * The following caveats apply (based off cursory testing, I'm sure there\n   * are other discrepancies):\n   *\n   * - Does not work inside comments:\n   *   ```\n   *   <!-- <div>broken</div> -->\n   *   ```\n   * - Does not work when tags have different cases:\n   *   ```\n   *   <div>broken</DIV>\n   *   ```\n   * - Does not work when cursor is inside a broken tag:\n   *   ```\n   *   <div><brok><en></div>\n   *   ```\n   * @arg {CodeMirror} cm \n   * @arg {Pos} head \n   * @arg {boolean} [inclusive]\n   */\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return { start: cur, end: cur };\n    }\n\n    var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return { start: cur, end: cur };\n    }\n\n    if (inclusive) {\n      return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n  }\n\n  /** @arg {CodeMirror} cm @arg {Pos} oldCur @arg {Pos} newCur */\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  /** @arg {number} increment  @arg {{ forward?: any; selectedCharacter?: any; }} args */\n  function recordLastCharacterSearch(increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment;\n      vimGlobalState.lastCharacterSearch.forward = args.forward;\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n\n  var symbolToMode = {\n      '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n      '[': 'section', ']': 'section',\n      '*': 'comment', '/': 'comment',\n      'm': 'method', 'M': 'method',\n      '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function(state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1)return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      }\n    },\n    section: {\n      init: function(state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function(state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function(state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    // TODO: The original Vim implementation only operates on level 1 and 2.\n    // The current implementation doesn't check for code block level and\n    // therefore it operates on any levels.\n    method: {\n      init: function(state) {\n        state.symb = (state.symb === 'm' ? '{' : '}');\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function(state) {\n        if (state.nextCh === state.symb)return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function(state) {\n        state.index = 0;\n      },\n      isComplete: function(state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === 'else' && state.depth === 0)return true;\n        }\n        return false;\n      }\n    }\n  };\n  /** @arg {CodeMirrorV} cm  @arg {number} repeat  @arg {boolean|undefined} forward  @arg {string} symb */\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode)return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) { init(state); }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = (lineLen > 0) ? (lineLen-1) : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n\n  /*\n    * Returns the boundaries of the next word. If the cursor in the middle of\n    * the word, then returns the boundaries of the current word, starting at\n    * the cursor. If the cursor is at the start/end of a word, and we are going\n    * forward/backward, respectively, find the boundaries of the next word.\n    *\n    * @arg {CodeMirror} cm CodeMirror object.\n    * @arg {Cursor} cur The cursor position.\n    * @arg {boolean} forward True to search forward. False to search\n    *     backward.\n    * @arg {boolean} bigWord True if punctuation count as part of the word.\n    *     False if only [a-zA-Z0-9] characters count as part of the word.\n    * @arg {boolean} emptyLineIsWord True if empty lines should be treated\n    *     as words.\n    * @return {Object{from:number, to:number, line: number}} The boundaries of\n    *     the word, or null if there are no more words.\n    */\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = (forward) ? 0 : line.length;\n    }\n\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return { from: 0, to: 0, line: lineNum };\n      }\n      var stop = (dir > 0) ? line.length : -1;\n      var wordStart = stop, wordEnd = stop;\n      // Find bounds of next word.\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            // Advance to end of word.\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (wordStart == cur.ch && lineNum == cur.line &&\n                wordEnd == wordStart + dir) {\n              // We started at the end of a word. Find the next one.\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      // Advance to next/prev line.\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = (dir > 0) ? 0 : line.length;\n    }\n  }\n\n  /**\n   * @arg {CodeMirror} cm CodeMirror object.\n   * @arg {Pos} cur The position to start from.\n   * @arg {number} repeat Number of words to move past.\n   * @arg {boolean} forward True to search forward. False to search\n   *     backward.\n   * @arg {boolean} wordEnd True to move to end of word. False to move to\n   *     beginning of word.\n   * @arg {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only alphabet characters count as part of the word.\n   * @return {Pos|undefined} The position the cursor should move to.\n   */\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n    // For 'e', empty lines are not considered words, go figure.\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward\n            ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n            : {line: 0, from: 0, to: 0});\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      // w\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return lastWord && new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return lastWord && new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      // ge\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return lastWord && new Pos(lastWord.line, lastWord.to);\n    } else {\n      // b\n      return lastWord && new Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {Pos} head \n   * @arg {MotionArgs} motionArgs \n   * @arg {vimState} vim \n   * @arg {boolean} keepHPos */\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end=cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end,'div').left;\n    }\n    return retval;\n  }\n\n  /** \n   * @arg {CodeMirror} cm \n   * @arg {number} repeat \n   * @arg {boolean} [forward]\n   * @arg {string} [character]\n   * @arg {Pos} [head]\n   */\n  function moveToCharacter(cm, repeat, forward, character, head) {\n    if (!character) return;\n    var cur = head || cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i ++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return undefined;\n      }\n      start = idx;\n    }\n    if (idx != undefined)\n      return new Pos(cm.getCursor().line, idx);\n  }\n\n  /** @arg {CodeMirrorV} cm @arg {number} repeat */\n  function moveToColumn(cm, repeat) {\n    // repeat is always >= 1, so repeat - 1 always corresponds\n    // to the column we want to go to.\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {vimState} vim \n   * @arg {string} markName \n   * @arg {Pos} pos */\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks) && !latinCharRegex.test(markName)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  /**\n   * @arg {number} start \n   * @arg {string | any[]} line \n   * @arg {any} character \n   * @arg {boolean} [forward] \n   * @arg {boolean} [includeChar] */\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    // Search for char in line.\n    // motion_options: {forward, includeChar}\n    // If includeChar = true, include it too.\n    // If forward = true, search forward, else search backwards.\n    // If char is not found on this line, do nothing\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n\n  /** @arg {CodeMirrorV} cm \n   * @arg {Pos} head \n   * @arg {number} repeat \n   * @arg {number} dir \n   * @arg {boolean} [inclusive] */\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start, end, i = line;\n    /** @arg {number} i */\n    function isEmpty(i) { return !cm.getLine(i); }\n    /** @arg {number} i @arg {number} dir @arg {boolean} [any] */\n    function isBoundary(i, dir, any) {\n      if (any) { return isEmpty(i) != isEmpty(i + dir); }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        if (isBoundary(i, dir)) { repeat--; }\n        i += dir;\n      }\n      return {start: new Pos(i, 0), end: head};\n    }\n\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    // select boundary before paragraph for the last one\n    if (i > max && !startState) { startState = true; }\n    else { inclusive = false; }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) { break; }\n      }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n  }\n\n  /**\n   * Based on {@link findSentence}. The internal functions have the same names,\n   * but their behaviour is different. findSentence() crosses line breaks and \n   * is used for jumping to sentence beginnings before or after the current cursor position, \n   * whereas getSentence() is for getting the beginning or end of the sentence \n   * at the current cursor position, either including (a) or excluding (i) whitespace.\n   * @arg {CodeMirror} cm\n   * @arg {Pos} cur\n   * @arg {number} repeat\n   * @arg {number} dir\n   * @arg {boolean} inclusive\n   */\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n\n    /*\n      Takes an index object\n      {\n        line: the line string,\n        ln: line number,\n        pos: index in line,\n        dir: direction of traversal (-1 or 1)\n      }\n      and modifies the pos member to represent the\n      next valid position or sets the line to null if there are\n      no more valid positions.\n      */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n        curr.line = null;\n      }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n      Performs one iteration of traversal in forward direction\n      Returns an index object of the sentence end\n      */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } \n          else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } \n              else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1 };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /** \n     * Performs one iteration of traversal in reverse direction\n     * Returns an index object of the sentence start\n     * @arg {CodeMirror} cm  \n     * @arg {number} ln  \n     * @arg {number} pos  \n     * @arg {number} dir\n     */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } \n          else {\n            if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n              return { ln: curr.ln, pos: curr.pos + 1 };\n            } \n            else {\n              return { ln: curr.ln, pos: lastSentencePos };\n            }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } \n      else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n      */\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n      }\n      else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    /*\n      Performs one iteration of traversal in forward direction\n      Returns an index object of the new location\n      */\n    /** @arg {CodeMirror} cm @arg {number} ln  @arg {number} pos  @arg {number} dir */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = (line === \"\");\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos,\n      };\n\n      var skip_empty_lines = (curr.line === \"\");\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return { ln: curr.ln, pos: curr.pos, };\n        }\n        else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return { ln: curr.ln, pos: curr.pos, };\n        }\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n          && !stop\n          && (curr.pos === curr.line.length - 1\n            || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the last non whitespace character on the last\n        valid line in the case that we reach the end of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for(var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n\n    }\n\n    /*\n      Performs one iteration of traversal in reverse direction\n      Returns an index object of the new location\n      */\n    /** @arg {CodeMirror} cm  @arg {number} ln  @arg {number} pos  @arg {number} dir */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      /** @type {{ln: number, pos: number|null}} */\n      var last_valid = {\n        ln: curr.ln,\n        pos: null,\n      };\n\n      var skip_empty_lines = (curr.line === \"\");\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          }\n          else {\n            return { ln: curr.ln, pos: curr.pos };\n          }\n        }\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && last_valid.pos !== null\n            && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        }\n        else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = { ln: curr.ln, pos: curr.pos };\n        }\n\n        nextChar(cm, curr);\n      }\n\n      /*\n        Set the position to the first non whitespace character on the last\n        valid line in the case that we reach the beginning of the document.\n      */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for(var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  // TODO: perhaps this finagling of start and end positions belongs\n  // in codemirror/replaceRange?\n  /** @arg {CodeMirror} cm  @arg {Pos} head @arg {string | number} symb @arg {boolean} inclusive */\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head;\n\n    var bracketRegexp = ({\n      '(': /[()]/, ')': /[()]/,\n      '[': /[[\\]]/, ']': /[[\\]]/,\n      '{': /[{}]/, '}': /[{}]/,\n      '<': /[<>]/, '>': /[<>]/})[symb];\n    var openSym = ({\n      '(': '(', ')': '(',\n      '[': '[', ']': '[',\n      '{': '{', '}': '{',\n      '<': '<', '>': '<'})[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    // Due to the behavior of scanForBracket, we need to add an offset if the\n    // cursor is on a matching open bracket.\n    var offset = curChar === openSym ? 1 : 0;\n\n    var startBracket = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n    var endBracket = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n    if (!startBracket || !endBracket) return null;\n\n    var start = startBracket.pos; \n    var end = endBracket.pos;\n\n    if ((start.line == end.line && start.ch > end.ch)\n        || (start.line > end.line)) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n\n    return { start: start, end: end };\n  }\n\n  // Takes in a symbol and a cursor and tries to simulate text objects that\n  // have identical opening and closing symbols\n  // TODO support across multiple lines\n  /** @arg {CodeMirror} cm  @arg {Pos} head  @arg {string} symb @arg {boolean} inclusive */\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    // the decision tree is to always look backwards for the beginning first,\n    // but if the cursor is in front of the first instance of the symb,\n    // then move the cursor forward\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    }\n    // otherwise if the cursor is currently on the closing symbol\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      var stringAfter = /string/.test(cm.getTokenTypeAt(offsetCursor(head, 0, 1)));\n      var stringBefore = /string/.test(cm.getTokenTypeAt(head));\n      var isStringStart = stringAfter && !stringBefore;\n      if (!isStringStart) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n    }\n\n    // if we're currently on the symbol, we've got a start\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      // go backwards to find the start\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    // look forwards for the end symbol\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    // nothing found\n    if (!start || !end) {\n      return { start: cur, end: cur };\n    }\n\n    // include the symbols\n    if (inclusive) {\n      --start; ++end;\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end)\n    };\n  }\n\n  // Search functions\n  defineOption('pcre', true, 'boolean');\n  \n  class SearchState {\n    getQuery() {\n      return vimGlobalState.query;\n    };\n    setQuery(query) {\n      vimGlobalState.query = query;\n    };\n    getOverlay() {\n      return this.searchOverlay;\n    };\n    setOverlay(overlay) {\n      this.searchOverlay = overlay;\n    };\n    isReversed() {\n      return vimGlobalState.isReversed;\n    };\n    setReversed(reversed) {\n      vimGlobalState.isReversed = reversed;\n    };\n    getScrollbarAnnotate() {\n      return this.annotate;\n    };\n    setScrollbarAnnotate(annotate) {\n      this.annotate = annotate;\n    };\n  }  /** @arg {CodeMirrorV} cm */\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  /** @arg {string} argString */\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n\n  /** @arg {string} argString */\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n\n  /** @arg {string} argString  @arg {string} separator */\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    // in case of strings like foo/bar\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number')\n        tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n    }\n    return tokens;\n  }\n\n  /** @arg {string} str  @arg {string} separator */\n  function findUnescapedSeparators(str, separator) {\n    if (!separator)\n      separator = '/';\n\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && (c == '\\\\');\n    }\n    return slashes;\n  }\n\n  // Translates a search string from ex (vim) syntax into javascript form.\n  /** @arg {string} str */\n  function translateRegex(str) {\n    // When these match, add a '\\' if unescaped or remove one if escaped.\n    var specials = '|(){';\n    // Remove, but never add, a '\\' for these.\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i+1) || '';\n      var specialComesNext = (n && specials.indexOf(n) != -1);\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          // Treat the unescape list as special for removing, but not adding '\\'.\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          // Not passing this test means removing a '\\'.\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Translates the replace part of a search and replace from ex (vim) syntax into\n  // javascript form.  Similar to translateRegex, but additionally fixes back references\n  // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n  /** @type{Object<string, string>} */\n  var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n  /** @arg {string} str */\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i+1) || '';\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c+n]);\n        i++;\n      } else if (escapeNextChar) {\n        // At any point in the loop, escapeNextChar is true if the previous\n        // character was a '\\' and was not escaped.\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n          if ((isNumber(n) || n === '$')) {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n          out.push(c);\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n    return out.join('');\n  }\n\n  // Unescape \\ and / in the replace part, for PCRE mode.\n  /** @type{Record<string, string>} */\n  var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n  /** @arg {string} str */\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      // Search for \\.\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        // Don't change anything\n        output.push(stream.next());\n      }\n    }\n    return output.join('');\n  }\n\n  /**\n   * Extract the regular expression from the query and return a Regexp object.\n   * Returns null if the query is blank.\n   * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n   * If smartCase is passed in, and the query contains upper case letters,\n   *   then ignoreCase is overridden, and the 'i' flag will not be set.\n   * If the query contains the /i in the flag part of the regular expression,\n   *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n   *   through to the Regex object.\n   * @arg {string|RegExp} query\n   * @arg {boolean} ignoreCase\n   * @arg {boolean} smartCase\n   */\n  function parseQuery(query, ignoreCase, smartCase) {\n    // First update the last search register\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n    // Check if the query is already a regex.\n    if (query instanceof RegExp) { return query; }\n    // First try to extract regex + flags from the input. If no flags found,\n    // extract just the regex. IE does not accept flags directly defined in\n    // the regex string in the form /regex/flags\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      // Query looks like 'regexp'\n      regexPart = query;\n    } else {\n      // Query looks like 'regexp/...'\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n    }\n    var regexp = new RegExp(regexPart,\n        (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n    return regexp;\n  }\n\n  /**\n   * dom - Document Object Manipulator\n   * Usage:\n   *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n   * Examples:\n   *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n   *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n   * Not supported:\n   *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n   * @arg {string | HTMLElement } n\n   */\n  function dom(n) {\n    if (typeof n === 'string') n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== 'object') a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);\n      else for (var key in a) {\n        if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n        if (key[0] === '$') n.style[key.slice(1)] = a[key];\n        else n.setAttribute(key, a[key]);\n      }\n    }\n    return n;\n  }\n\n  /** @arg {CodeMirror} cm  @arg {any} template */\n  function showConfirm(cm, template) {\n    var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, {bottom: true, duration: 5000});\n    } else {\n      alert(pre.innerText);\n    }\n  }\n  /** @arg {string} prefix  @arg {string} desc */\n  function makePrompt(prefix, desc) {\n    return dom('div', {$display: 'flex'},\n              dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre', $flex: 1},\n                prefix,\n                dom('input', {type: 'text', autocorrect: 'off',\n                              autocapitalize: 'off', spellcheck: 'false', $width: '100%'})),\n              desc && dom('span', {$color: '#888'}, desc));\n  }\n  /**\n   * @arg {CodeMirror} cm \n   * @arg {{ onClose?: any; prefix: any; desc?: any; onKeyUp?: any; onKeyDown: any; value?: any; selectValueOnOpen?: boolean; }} options \n   */\n  function showPrompt(cm, options) {\n    if (keyToKeyStack.length) {\n      if (!options.value) options.value = '';\n      virtualPrompt = options;\n      return;\n    }\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n        bottom: true, selectValueOnOpen: false, value: options.value\n      });\n    }\n    else {\n      var shortText = '';\n      if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, ''));\n    }\n  }\n\n  /** @arg {RegExp|unknown} r1  @arg {RegExp|unknown} r2 */\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n        for (var i = 0; i < props.length; i++) {\n            var prop = props[i];\n            if (r1[prop] !== r2[prop]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n  // Returns true if the query is valid.\n  /**\n   * @arg {CodeMirrorV} cm \n   * @arg {string | RegExp} rawQuery \n   * @arg {boolean | undefined} [ignoreCase] \n   * @arg {boolean | undefined} [smartCase]\n  */\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  /** @arg {RegExp} query */\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n    return {\n      token: function(stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            // Matched empty string, skip to next.\n            stream.next();\n            return 'searching';\n          }\n          if (!stream.sol()) {\n            // Backtrack 1 to match \\b\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return 'searching';\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n  var highlightTimeout = 0;\n  /** @arg {CodeMirrorV} cm  @arg {RegExp} query */\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    var searchState = getSearchState(cm);\n    searchState.highlightTimeout = highlightTimeout;\n    highlightTimeout = setTimeout(function() {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      searchState.highlightTimeout = null;\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  /** @arg {CodeMirror} cm @arg {boolean} prev @arg {RegExp} query @arg {number | undefined} [repeat] */\n  function findNext(cm, prev, query, repeat) {\n    return cm.operation(function() {\n      if (repeat === undefined) { repeat = 1; }\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        // @ts-ignore\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          // @ts-ignore\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            // @ts-ignore\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n              found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query,\n              // @ts-ignore\n              (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  /**\n   * Pretty much the same as `findNext`, except for the following differences:\n   *\n   * 1. Before starting the search, move to the previous search. This way if our cursor is\n   * already inside a match, we should return the current match.\n   * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n   * @arg {CodeMirror} cm\n   * @arg {boolean} prev\n   * @arg {any} query\n   * @arg {number | undefined} repeat\n   * @arg {vimState} vim\n   */\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    return cm.operation(function() {\n      if (repeat === undefined) { repeat = 1; }\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      // Go back one result to ensure that if the cursor is currently a match, we keep it.\n      var found = cursor.find(!prev);\n\n      // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n      // @ts-ignore\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(query,\n              // @ts-ignore\n              (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  /** @arg {CodeMirrorV} cm */\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    if (state.highlightTimeout) {\n      clearTimeout(state.highlightTimeout);\n      state.highlightTimeout = null;\n    }\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  /**\n   * Check if pos is in the specified range, INCLUSIVE.\n   * Range can be specified with 1 or 2 arguments.\n   * If the first range argument is an array, treat it as an array of line\n   * numbers. Match pos against any of the lines.\n   * If the first range argument is a number,\n   *   if there is only 1 range argument, check if pos has the same line\n   *       number\n   *   if there are 2 range arguments, then check if pos is in between the two\n   *       range arguments.\n   * @arg {number|Pos} pos\n   * @arg {number|number[]} start\n   * @arg {number} end\n   */\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      // Assume it is a cursor position. Get the line number.\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == 'number') {\n        return (pos >= start && pos <= end);\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  /** @arg {CodeMirror} cm */\n  function getUserVisibleLines(cm) {\n    var scrollInfo = cm.getScrollInfo();\n    var occludeToleranceTop = 6;\n    var occludeToleranceBottom = 10;\n    var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n    var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n    var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n    return {top: from.line, bottom: to.line};\n  }\n\n  /** @arg {CodeMirror} cm @arg {vimState} vim  @arg {string} markName */\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  /** @arg {CodeMirror} cm */\n  function getLastEditPos(cm) {\n    if (cm.getLastEditEnd) {\n      return cm.getLastEditEnd();\n    }\n    // for old cm\n    var done = /**@type{any}*/(cm).doc.history.done;\n    for (var i = done.length; i--;) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n\n  class ExCommandDispatcher {\n    constructor() {\n      /**@type {Record<string, any>} */\n      this.commandMap_;\n      this.buildCommandMap_();\n    }\n    processCommand(cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    }\n    _processCommand(cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n      var inputStream = new CodeMirror.StringStream(input);\n      // update \": with the latest command whether valid or invalid\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch(e) {\n        showConfirm(cm, e + \"\");\n        throw e;\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        // If only a line range is defined, move to the line.\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == 'exToKey') {\n            // Handle Ex to Key mapping.\n            doKeyToKey(cm, command.toKeys, command);\n            return;\n          } else if (command.type == 'exToEx') {\n            // Handle Ex to Ex mapping.\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        // Possibly asynchronous commands (e.g. substitute, which might have a\n        // user confirmation), are responsible for calling the callback when\n        // done. All others have it taken care of for them here.\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch(e) {\n        showConfirm(cm, e + \"\");\n        throw e;\n      }\n    }\n    parseInput_(cm, inputStream, result) {\n      inputStream.eatWhile(':');\n      // Parse range.\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n\n      if (result.line == undefined) {\n        if (cm.state.vim.visualMode) {\n          result.selectionLine = getMarkPos(cm, cm.state.vim, '<')?.line;\n          result.selectionLineEnd = getMarkPos(cm, cm.state.vim, '>')?.line;\n        } else {\n          result.selectionLine = cm.getCursor().line;\n        }\n      } else {\n        result.selectionLine = result.line;\n        result.selectionLineEnd = result.lineEnd;\n      }\n\n      // Parse command name.\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n\n      return result;\n    }\n    parseLineSpec_(cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        // Absolute line number plus offset (N+M or N-M) is probably a typo,\n        // not something the user actually wanted. (NB: vim does allow this.)\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          // Offset is relative to current line if not otherwise specified.\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    }\n    parseLineSpecOffset_(inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    }\n    parseCommandArgs_(inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      // Parse command-line arguments\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    }\n    matchCommand_(commandName) {\n      // Return the command in the command map that matches the shortest\n      // prefix of the passed in command name. The match is guaranteed to be\n      // unambiguous if the defaultExCommandMap's shortNames are set up\n      // correctly. (see @code{defaultExCommandMap}).\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    }\n    buildCommandMap_() {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    }\n    /**@type {(lhs: string, rhs: string, ctx: string, noremap?: boolean) => void} */\n    map(lhs, rhs, ctx, noremap) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) { throw Error('Mode not supported for ex mappings'); }\n        var commandName = lhs.substring(1);\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          // Ex to Ex mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          // Ex to key mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        // Key to key or ex mapping\n        var mapping = {\n          keys: lhs,\n          type: 'keyToKey',\n          toKeys: rhs,\n          noremap: !!noremap\n        };\n        if (ctx) { mapping.context = ctx; }\n        // @ts-ignore\n        defaultKeymap.unshift(mapping);\n      }\n    }\n    /**@type {(lhs: string, ctx: string) => boolean|void} */\n    unmap(lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        // Ex to Ex or Ex to key mapping\n        if (ctx) { throw Error('Mode not supported for ex mappings'); }\n        var commandName = lhs.substring(1);\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        // Key to Ex or key to key mapping\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys\n              && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    }\n  }\n\n  /** @typedef { import(\"./types\").ExParams} ExParams */\n  var exCommands = {\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    colorscheme: function(cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function(cm, params, ctx, defaultOnly) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx, defaultOnly);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    imap: function(cm, params) { this.map(cm, params, 'insert'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    omap: function(cm, params) { this.map(cm, params, 'operatorPending'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    noremap: function(cm, params) { this.map(cm, params, undefined, true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    inoremap: function(cm, params) { this.map(cm, params, 'insert', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nnoremap: function(cm, params) { this.map(cm, params, 'normal', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vnoremap: function(cm, params) { this.map(cm, params, 'visual', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    onoremap: function(cm, params) { this.map(cm, params, 'operatorPending', true); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params @arg {string} ctx*/\n    unmap: function(cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    mapclear: function(cm, params) { vimApi.mapclear(); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    imapclear: function(cm, params) { vimApi.mapclear('insert'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    nmapclear: function(cm, params) { vimApi.mapclear('normal'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vmapclear: function(cm, params) { vimApi.mapclear('visual'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    omapclear: function(cm, params) { vimApi.mapclear('operatorPending'); },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    move: function(cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        keys: \"\",\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: { forward: false, explicitRepeat: true, linewise: true },\n        repeatOverride: params.line+1\n      });\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    set: function(cm, params) {\n      var setArgs = params.args;\n      // Options passed through to the setOption/getOption calls. May be passed in by the\n      // local/global versions of the set command\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split('=');\n      var optionName = expr.shift() || \"\";\n      /**@type {string|boolean|undefined} */\n      var value = expr.length > 0 ? expr.join('=') : undefined;\n      var forceGet = false;\n      var forceToggle = false;\n\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        // If post-fixed with ?, then the set is actually a get.\n        if (value) { throw Error('Trailing characters: ' + params.argString); }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      } else if (optionName.charAt(optionName.length - 1) == '!') {\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceToggle = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        // To set boolean options to false, the option name is prefixed with\n        // 'no'.\n        optionName = optionName.substring(2);\n        value = false;\n      }\n\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n      if (optionIsBoolean) {\n        if (forceToggle) {\n          value = !getOption(optionName, cm, setCfg);\n        } else if (value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n      }\n      // If no value is provided, then we assume this is a get.\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    setlocal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {scope: 'local'};\n      this.set(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    setglobal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = {scope: 'global'};\n      this.set(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    registers: function(cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------\\n\\n';\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '\\n';\n          }\n        }\n      } else {\n        var registerNames = regArgs.join('');\n        for (var i = 0; i < registerNames.length; i++) {\n          var registerName = registerNames.charAt(i);\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    sort: function(cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat('!')) { reverse = true; }\n          if (args.eol()) { return; }\n          if (!args.eatSpace()) { return 'Invalid arguments'; }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts || !args.eol()) { return 'Invalid arguments'; }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1;\n            var hex = opts[1].indexOf('x') != -1;\n            var octal = opts[1].indexOf('o') != -1;\n            if (Number(decimal) + Number(hex) + Number(octal) > 1) { return 'Invalid arguments'; }\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) { return; }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex =\n          (number == 'decimal') ? /(-?)([\\d]+)/ :\n          (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n          (number == 'octal') ? /([0-7]+)/ : null;\n      var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : undefined;\n      var numPart = [], textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (numberRegex && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      /** @arg {string} a  @arg {string} b */\n      function compareFn(a, b) {\n        if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n        if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n        var amatch = numberRegex && numberRegex.exec(a);\n        var bmatch = numberRegex && numberRegex.exec(b);\n        if (!amatch || !bmatch) { return a < b ? -1 : 1; }\n        var anum = parseInt((amatch[1] + amatch[2]).toLowerCase(), radix);\n        var bnum = parseInt((bmatch[1] + bmatch[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      /** @arg {string[]} a  @arg {string[]} b */\n      function comparePatternFn(a, b) {\n        if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n        if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n        return (a[0] < b[0]) ? -1 : 1;\n      }\n      // @ts-ignore\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          // @ts-ignore\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) { textPart.sort(compareFn); }\n      text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) { // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    vglobal: function(cm, params) {\n      // global inspects params.commandName\n      this.global(cm, params);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    normal: function(cm, params) {\n      var argString = params.argString;\n      if (argString && argString[0] == '!') {\n          argString = argString.slice(1);\n          noremap = true;\n      }\n      argString = argString.trimStart();\n      if (!argString) {\n        showConfirm(cm, 'Argument is required.');\n        return;\n      }\n      var line = params.line;\n      if (typeof line == 'number') {\n        var lineEnd = isNaN(params.lineEnd) ? line : params.lineEnd;\n        for (var i = line; i <= lineEnd; i++) {\n          cm.setCursor(i, 0);\n          doKeyToKey(cm, params.argString.trimStart());\n          if (cm.state.vim.insertMode) {\n            exitInsertMode(cm, true);\n          }\n        }\n      } else {\n        doKeyToKey(cm, params.argString.trimStart());\n        if (cm.state.vim.insertMode) {\n          exitInsertMode(cm, true);\n        }\n      }\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    global: function(cm, params) {\n      // a global command is of the form\n      // :[range]g/pattern/[cmd]\n      // argString holds the string /pattern/[cmd]\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n      var inverted = params.commandName[0] === 'v';\n      if (argString[0] === '!' && params.commandName[0] === 'g') {\n        inverted = true;\n        argString = argString.slice(1);\n      }\n      // range is specified here\n      var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      // get the tokens from argString\n      var tokens = splitBySlash(argString);\n      var regexPart = argString, cmd = \"\";\n      if (tokens && tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise\n        // use the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n            true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      // now that we have the regexPart, search for regex matches in the\n      // specified range of lines\n      var query = getSearchState(cm).getQuery();\n      /**@type {(string|import(\"./types\").LineHandle)[]}*/\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLine(i);\n        var matched = query.test(line);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? cm.getLineHandle(i) : line);\n        }\n      }\n      // if there is no [cmd], just display the list of matched lines\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join('\\n'));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function() {\n        if (index < matchedLines.length) {\n          var lineHandle = matchedLines[index++];\n          var lineNum = cm.getLineNumber(lineHandle);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = (lineNum + 1) + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        } else if (cm.releaseLineHandles) {\n          cm.releaseLineHandles();\n        }\n      };\n      nextCommand();\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    substitute: function(cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' +\n            'any other getSearchCursor implementation.');\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart = '', replacePart = '', trailing, flagsPart, count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens && tokens.length) {\n        regexPart = tokens[0];\n        if (getOption('pcre') && regexPart !== '') {\n            regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        // either the argString is empty or its of the form ' hello/world'\n        // actually splitBySlash returns a list of tokens\n        // only if the string starts with a '/'\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' +\n              ':s/pattern/replace/');\n          return;\n        }\n      }\n      // After the 3rd slash, we can have flags followed by a space followed\n      // by count.\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n          }\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise use\n        // the regex part as the new query.\n        try {\n          updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n            true /** smartCase */);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    startinsert: function(cm, params) {\n      doKeyToKey(cm, params.argString == '!' ? 'A' : 'i', {});\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    /** @arg {CodeMirrorV} cm */\n    write: function(cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        // Saves to text area if no save command is defined and cm.save() is available.\n        cm.save();\n      }\n    },\n    /** @arg {CodeMirrorV} cm */\n    nohlsearch: function(cm) {\n      clearSearchHighlight(cm);\n    },\n    /** @arg {CodeMirrorV} cm */\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText(\n        '0', 'yank', lineText, true, true);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    delete: function(cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      operators.delete(cm, {linewise: true}, [\n        { anchor: new Pos(line, 0),\n          head: new Pos(lineEnd + 1, 0) }\n      ]);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    join: function(cm, params) {\n      var line = params.selectionLine;\n      var lineEnd = isNaN(params.selectionLineEnd) ? line : params.selectionLineEnd;\n      cm.setCursor(new Pos(line, 0));\n      actions.joinLines(cm, {repeat: lineEnd - line}, cm.state.vim);\n    },\n    /** @arg {CodeMirrorV} cm @arg {ExParams} params*/\n    delmarks: function(cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n\n        // Record the streams position at the beginning of the loop for use\n        // in error messages.\n        var count = stream.pos;\n\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n\n        var sym = stream.next();\n        // Check if this symbol is part of a range\n        if (stream.match('-', true)) {\n          // This symbol is part of a range.\n\n          // The range must terminate at an alphabetic character.\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var startMark = sym;\n          var finishMark = stream.next();\n          // The range must terminate at an alphabetic character which\n          // shares the same case as the start of the range.\n          if (startMark && finishMark && isLowerCase(startMark) == isLowerCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            // Because marks are always ASCII values, and we have\n            // determined that they are the same case, we can use\n            // their char codes to iterate through the defined range.\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else if (sym) {\n          // This symbol is a valid mark, and is not part of a range.\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n/**\n * @arg {CodeMirrorV} cm CodeMirror instance we are in.\n * @arg {boolean} confirm Whether to confirm each replace.\n * @arg {boolean} global \n * @arg {number} lineStart Line to start replacing from.\n * @arg {number} lineEnd Line to stop replacing at.\n * @arg {RegExp} query Query for performing matches with.\n * @arg {string} replaceWith Text to replace matches with. May contain $1,\n *     $2, etc for replacing captured groups using JavaScript replace.\n * @arg {function} [callback] A callback for when the replace is done.\n */\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n      replaceWith, callback) {\n    // Set up all the functions.\n    cm.state.vim.exMode = true;\n    var done = false;\n    \n    /** @type {Pos}*/ var lastPos;\n    /** @type {number}*/ var modifiedLineNumber;\n    /** @type {boolean}*/var joined;\n    function replaceAll() {\n      cm.operation(function() {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      // The below only loops to skip over multiple occurrences on the same\n      // line when 'global' is not true.\n      while(findNextValidMatch() &&\n            isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    /** @arg {(() => void) | undefined} [close] */\n    function stop(close) {\n      if (close) { close(); }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) { callback(); }\n    }\n    /** @arg {KeyboardEvent} e   @arg {any} _value   @arg {any} close */\n    function onPromptKeyDown(e, _value, close) {\n      // Swallow all keys.\n      CodeMirror.e_stop(e);\n      var keyName = vimKeyFromEvent(e);\n      switch (keyName) {\n        case 'y':\n          replace(); next(); break;\n        case 'n':\n          next(); break;\n        case 'a':\n          // replaceAll contains a call to close of its own. We don't want it\n          // to fire too early or multiple times.\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case 'l':\n          replace();\n          // fall through and exit.\n        case 'q':\n        case '<Esc>':\n        case '<C-c>':\n        case '<C-[>':\n          stop(close);\n          break;\n      }\n      if (done) { stop(close); }\n      return true;\n    }\n\n    // Actually do replace.\n    next();\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) { callback(); }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n      onKeyDown: onPromptKeyDown\n    });\n  }\n\n  /** @arg {CodeMirrorV} cm  @arg {boolean} [keepCursor] */\n  function exitInsertMode(cm, keepCursor) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      if (vim.insertEnd) vim.insertEnd.clear();\n      vim.insertEnd = undefined;\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      // Perform insert mode repeat for commands like 3,a and 3,o.\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n          true /** repeatForInsert */);\n      // @ts-ignore\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    if (!keepCursor) {\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n    }\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    // update the \". register before exiting insert mode\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n\n  /** @arg {vimKey} command*/\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n\n  /** \n   * @arg {string} keys\n   * @arg {string} type   \n   * @arg {string} name\n   * @arg {any} args\n   * @arg {{ [x: string]: any; }} extra \n   **/\n  function mapCommand(keys, type, name, args, extra) {\n    /**@type{any} */\n    var command = {keys: keys, type: type};\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra)\n      command[key] = extra[key];\n    _mapCommand(command);\n  }\n\n  // The timeout in milliseconds for the two-character ESC keymap should be\n  // adjusted according to your typing speed to prevent false positives.\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n\n  /**\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState} vim \n   * @arg {MacroModeState} macroModeState \n   * @arg {string} registerName\n   */\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == ':') {\n      // Read-only register containing last Ex command.\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      var keyRe = /<(?:[CSMA]-)*\\w+>|./gi;\n      while ((match = keyRe.exec(text))) {\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        key = match[0];\n        vimApi.handleKey(cm, key, 'macro');\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n\n  /** @arg {MacroModeState} macroModeState @arg {any} key */\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) { return; }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  /** @arg {MacroModeState} macroModeState */\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) { return; }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  /** @arg {MacroModeState} macroModeState @arg {string} query */\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) { return; }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  /**\n   * Listens for changes made in insert mode.\n   * Should only be active in insert mode.\n   * @arg {CodeMirror} cm\n   * @arg {{ origin: string | undefined; text: any[]; next: any; }} changeObj\n   */\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      var vim = cm.state.vim;\n      while(changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        // @ts-ignore\n        if (lastChange.ignoreCount > 1) {\n          // @ts-ignore\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n            || changeObj.origin === undefined /* only in testing */) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1)\n            lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join('\\n');\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              if (text.length > 1) {\n                var insertEnd = vim && vim.insertEnd && vim.insertEnd.find();\n                var cursor = cm.getCursor();\n                if (insertEnd && insertEnd.line == cursor.line) {\n                  var offset = insertEnd.ch - cursor.ch;\n                  if (offset > 0 && offset < text.length) {\n                    lastChange.changes.push([text, offset]);\n                    text = '';\n                  }\n                }\n              }\n              if (text) lastChange.changes.push(text);\n            }\n          }\n        }\n        // Change objects may be chained with next.\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  /**\n   * Listens for any kind of cursor activity on CodeMirror.\n   * @arg {CodeMirrorV} cm\n   */\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      // Tracking cursor activity in insert mode (for macro support).\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) { return; }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.maybeReset = true;\n        if (vim.insertEnd) vim.insertEnd.clear();\n        vim.insertEnd = cm.setBookmark(cm.getCursor(), {insertLeft: true});\n      }\n    } else if (!cm.curOp?.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  /** @arg {CodeMirrorV} cm  @arg {vimState} vim */\n  function handleExternalSelection(cm, vim) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n    // Enter or exit visual mode to match mouse selection.\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n    }\n    if (vim.visualMode) {\n      // Bind CodeMirror selection model to vim selection model.\n      // Mouse selections are considered visual characterwise.\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode) {\n      // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  /**\n   * Wrapper for special keys pressed in insert mode\n   * @arg {string} keyName\n   */\n  function InsertModeKey(keyName, e) {\n    this.keyName = keyName;\n    this.key = e.key;\n    this.ctrlKey = e.ctrlKey;\n    this.altKey = e.altKey;\n    this.metaKey = e.metaKey;\n    this.shiftKey = e.shiftKey;\n  }\n\n  /**\n   * Handles raw key down events from the text area.\n   * - Should only be active in insert mode.\n   * - For recording deletes in insert mode.\n   * @arg {KeyboardEvent} e\n   */\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName ? CodeMirror.keyName(e) : e.key;\n    if (!keyName) { return; }\n    \n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName, e));\n    }\n  }\n\n  /**\n   * Repeats the last edit, which includes exactly 1 command and at most 1\n   * insert. Operator and motion commands are read from lastEditInputState,\n   * while action commands are read from lastEditActionCommand.\n   *\n   * If repeatForInsert is true, then the function was called by\n   * exitInsertMode to repeat the insert mode changes the user just made. The\n   * corresponding enterInsertMode call was made with a count.\n   * @arg {CodeMirrorV} cm \n   * @arg {vimState} vim \n   * @arg {number} repeat  \n   * @arg {boolean} repeatForInsert\n   */\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var lastAction = vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (lastAction) {\n        commandDispatcher.processAction(cm, vim, lastAction);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    /** @arg {number} repeat */\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        // For some reason, repeat cw in desktop VIM does not repeat\n        // insert mode changes. Will conform to that behavior.\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    // @ts-ignore\n    vim.inputState = vim.lastEditInputState;\n    if (lastAction && lastAction.interlaceInsertRepeat) {\n      // o and O repeat have to be interlaced with insert repeats so that the\n      // insertions appear on separate lines instead of the last line.\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        // Hack to get the cursor to end up at the right place. If I is\n        // repeated in insert mode repeat, cursor will be 1 insert\n        // change set left of where it should be.\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      // Don't exit insert mode twice. If repeatForInsert is set, then we\n      // were called by an exitInsertMode call lower on the stack.\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n  /**@arg {CodeMirrorV} cm, @arg {string} key */\n  function sendCmKey(cm, key) {\n    CodeMirror.lookupKey(key, 'vim-insert', function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    });\n  }\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      // Set up block selection again for repeating the changes.\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          sendCmKey(cm, change.keyName);\n        } else if (typeof change == \"string\") {\n          cm.replaceSelection(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length - (change[1] || 0));\n          cm.replaceRange(change[0], start, change[1] ? start: end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  // multiselect support\n  /** @arg {vimState} state */\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function(key) {\n      if (key == \"insertEnd\") return;\n      var o = state[key];\n      if (Array.isArray(o))\n        o = o.slice();\n      else if (o && typeof o == \"object\" && o.constructor != Object)\n        o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  /** @arg {CodeMirror} cm_  @arg {string} key @arg {string} origin */\n  function multiSelectHandleKey(cm_, key, origin) {\n    var vim = maybeInitVimState(cm_);\n    var cm = /**@type {CodeMirrorV}*/(cm_);\n    /** @type {boolean | undefined} */\n    var isHandled = false;\n    var vim = vimApi.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n    var wasMultiselect = cm.isInMultiSelectMode();\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n        vim.wasInVisualBlock = true;\n    }\n\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n      // allow editor to exit multiselect\n      clearInputState(cm);\n    // @ts-ignore\n    } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n      isHandled = vimApi.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      var changeQueueList = vim.inputState.changeQueueList || [];\n\n      cm.operation(function() {\n        if (cm.curOp)\n          cm.curOp.isVimOp = true;\n        var index = 0;\n        cm.forEachSelection(function() {\n          cm.state.vim.inputState.changeQueue = changeQueueList[index];\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n\n          isHandled = vimApi.handleKey(cm, key, origin);\n          if (cm.virtualSelection) {\n            changeQueueList[index] = cm.state.vim.inputState.changeQueue;\n            cm.state.vim = cloneVimState(old);\n          }\n          index++;\n        });\n        if (cm.curOp?.cursorActivity && !isHandled)\n          cm.curOp.cursorActivity = false;\n        cm.state.vim = vim;\n        vim.inputState.changeQueueList = changeQueueList;\n        vim.inputState.changeQueue = null;\n      }, true);\n    }\n    // some commands may bring visualMode and selection out of sync\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim);\n    }\n    return isHandled;\n  }\n  resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction indexFromPos(doc, pos) {\n    var ch = pos.ch;\n    var lineNumber = pos.line + 1;\n    if (lineNumber < 1) {\n        lineNumber = 1;\n        ch = 0;\n    }\n    if (lineNumber > doc.lines) {\n        lineNumber = doc.lines;\n        ch = Number.MAX_VALUE;\n    }\n    var line = doc.line(lineNumber);\n    return Math.min(line.from + Math.max(0, ch), line.to);\n}\nfunction posFromIndex(doc, offset) {\n    let line = doc.lineAt(offset);\n    return { line: line.number - 1, ch: offset - line.from };\n}\nclass Pos {\n    constructor(line, ch) {\n        this.line = line;\n        this.ch = ch;\n    }\n}\nfunction on(emitter, type, f) {\n    if (emitter.addEventListener) {\n        emitter.addEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers || (emitter._handlers = {});\n        map[type] = (map[type] || []).concat(f);\n    }\n}\nfunction off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n        emitter.removeEventListener(type, f, false);\n    }\n    else {\n        var map = emitter._handlers, arr = map && map[type];\n        if (arr) {\n            var index = arr.indexOf(f);\n            if (index > -1) {\n                map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n            }\n        }\n    }\n}\nfunction signal(emitter, type, ...args) {\n    var _a;\n    var handlers = (_a = emitter._handlers) === null || _a === void 0 ? void 0 : _a[type];\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nfunction signalTo(handlers, ...args) {\n    if (!handlers)\n        return;\n    for (var i = 0; i < handlers.length; ++i) {\n        handlers[i](...args);\n    }\n}\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\w\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) {\n    wordChar = /[\\w]/;\n}\n// workaround for missing api for merging transactions\nfunction dispatchChange(cm, transaction) {\n    var view = cm.cm6;\n    if (view.state.readOnly)\n        return;\n    var type = \"input.type.compose\";\n    if (cm.curOp) {\n        if (!cm.curOp.lastChange)\n            type = \"input.type.compose.start\";\n    }\n    if (transaction.annotations) {\n        try {\n            transaction.annotations.some(function (note) {\n                if (note.value == \"input\")\n                    note.value = type;\n            });\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    else {\n        transaction.userEvent = type;\n    }\n    return view.dispatch(transaction);\n}\nfunction runHistoryCommand(cm, revert) {\n    var _a;\n    if (cm.curOp) {\n        cm.curOp.$changeStart = undefined;\n    }\n    (revert ? undo : redo)(cm.cm6);\n    let changeStartIndex = (_a = cm.curOp) === null || _a === void 0 ? void 0 : _a.$changeStart;\n    // vim mode expects the changed text to be either selected or cursor placed at the start\n    if (changeStartIndex != null) {\n        cm.cm6.dispatch({ selection: { anchor: changeStartIndex } });\n    }\n}\nvar keys = {};\n/*@__PURE__*/\"Left|Right|Up|Down|Backspace|Delete\".split(\"|\").forEach(key => {\n    keys[key] = (cm) => runScopeHandlers(cm.cm6, { key: key }, \"editor\");\n});\nclass CodeMirror {\n    constructor(cm6) {\n        this.state = {};\n        this.marks = Object.create(null);\n        this.$mid = 0; // marker id counter\n        this.options = {};\n        this._handlers = {};\n        this.$lastChangeEndOffset = 0;\n        this.virtualSelection = null;\n        this.cm6 = cm6;\n        this.onChange = this.onChange.bind(this);\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    // --------------------------\n    openDialog(template, callback, options) {\n        return openDialog(this, template, callback, options);\n    }\n    ;\n    openNotification(template, options) {\n        return openNotification(this, template, options);\n    }\n    ;\n    ;\n    on(type, f) { on(this, type, f); }\n    off(type, f) { off(this, type, f); }\n    signal(type, e, handlers) { signal(this, type, e, handlers); }\n    indexFromPos(pos) {\n        return indexFromPos(this.cm6.state.doc, pos);\n    }\n    ;\n    posFromIndex(offset) {\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    foldCode(pos) {\n        let view = this.cm6;\n        let ranges = view.state.selection.ranges;\n        let doc = this.cm6.state.doc;\n        let index = indexFromPos(doc, pos);\n        let tmpRanges = EditorSelection.create([EditorSelection.range(index, index)], 0).ranges;\n        view.state.selection.ranges = tmpRanges;\n        foldCode(view);\n        view.state.selection.ranges = ranges;\n    }\n    firstLine() { return 0; }\n    ;\n    lastLine() { return this.cm6.state.doc.lines - 1; }\n    ;\n    lineCount() { return this.cm6.state.doc.lines; }\n    ;\n    setCursor(line, ch) {\n        if (typeof line === 'object') {\n            ch = line.ch;\n            line = line.line;\n        }\n        var offset = indexFromPos(this.cm6.state.doc, { line, ch: ch || 0 });\n        this.cm6.dispatch({ selection: { anchor: offset } }, { scrollIntoView: !this.curOp });\n        if (this.curOp && !this.curOp.isVimOp)\n            this.onBeforeEndOperation();\n    }\n    ;\n    getCursor(p) {\n        var sel = this.cm6.state.selection.main;\n        var offset = p == \"head\" || !p\n            ? sel.head\n            : p == \"anchor\"\n                ? sel.anchor\n                : p == \"start\"\n                    ? sel.from\n                    : p == \"end\"\n                        ? sel.to\n                        : null;\n        if (offset == null)\n            throw new Error(\"Invalid cursor type\");\n        return this.posFromIndex(offset);\n    }\n    ;\n    listSelections() {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.selection.ranges.map(r => {\n            return {\n                anchor: posFromIndex(doc, r.anchor),\n                head: posFromIndex(doc, r.head),\n            };\n        });\n    }\n    ;\n    setSelections(p, primIndex) {\n        var doc = this.cm6.state.doc;\n        var ranges = p.map(x => {\n            var head = indexFromPos(doc, x.head);\n            var anchor = indexFromPos(doc, x.anchor);\n            // workaround for codemirror bug, see https://github.com/replit/codemirror-vim/issues/169\n            if (head == anchor)\n                return EditorSelection.cursor(head, 1);\n            return EditorSelection.range(anchor, head);\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, primIndex)\n        });\n    }\n    ;\n    setSelection(anchor, head, options) {\n        this.setSelections([{ anchor, head }], 0);\n        if (options && options.origin == '*mouse') {\n            this.onBeforeEndOperation();\n        }\n    }\n    ;\n    getLine(row) {\n        var doc = this.cm6.state.doc;\n        if (row < 0 || row >= doc.lines)\n            return \"\";\n        return this.cm6.state.doc.line(row + 1).text;\n    }\n    ;\n    getLineHandle(row) {\n        if (!this.$lineHandleChanges)\n            this.$lineHandleChanges = [];\n        return { row: row, index: this.indexFromPos(new Pos(row, 0)) };\n    }\n    getLineNumber(handle) {\n        var updates = this.$lineHandleChanges;\n        if (!updates)\n            return null;\n        var offset = handle.index;\n        for (var i = 0; i < updates.length; i++) {\n            offset = updates[i].changes.mapPos(offset, 1, MapMode.TrackAfter);\n            if (offset == null)\n                return null;\n        }\n        var pos = this.posFromIndex(offset);\n        return pos.ch == 0 ? pos.line : null;\n    }\n    releaseLineHandles() {\n        this.$lineHandleChanges = undefined;\n    }\n    getRange(s, e) {\n        var doc = this.cm6.state.doc;\n        return this.cm6.state.sliceDoc(indexFromPos(doc, s), indexFromPos(doc, e));\n    }\n    ;\n    replaceRange(text, s, e, source) {\n        if (!e)\n            e = s;\n        var doc = this.cm6.state.doc;\n        var from = indexFromPos(doc, s);\n        var to = indexFromPos(doc, e);\n        dispatchChange(this, { changes: { from, to, insert: text } });\n    }\n    ;\n    replaceSelection(text) {\n        dispatchChange(this, this.cm6.state.replaceSelection(text));\n    }\n    ;\n    replaceSelections(replacements) {\n        var ranges = this.cm6.state.selection.ranges;\n        var changes = ranges.map((r, i) => {\n            return { from: r.from, to: r.to, insert: replacements[i] || \"\" };\n        });\n        dispatchChange(this, { changes });\n    }\n    ;\n    getSelection() {\n        return this.getSelections().join(\"\\n\");\n    }\n    ;\n    getSelections() {\n        var cm = this.cm6;\n        return cm.state.selection.ranges.map(r => cm.state.sliceDoc(r.from, r.to));\n    }\n    ;\n    somethingSelected() {\n        return this.cm6.state.selection.ranges.some(r => !r.empty);\n    }\n    ;\n    getInputField() {\n        return this.cm6.contentDOM;\n    }\n    ;\n    clipPos(p) {\n        var doc = this.cm6.state.doc;\n        var ch = p.ch;\n        var lineNumber = p.line + 1;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            ch = 0;\n        }\n        if (lineNumber > doc.lines) {\n            lineNumber = doc.lines;\n            ch = Number.MAX_VALUE;\n        }\n        var line = doc.line(lineNumber);\n        ch = Math.min(Math.max(0, ch), line.to - line.from);\n        return new Pos(lineNumber - 1, ch);\n    }\n    ;\n    getValue() {\n        return this.cm6.state.doc.toString();\n    }\n    ;\n    setValue(text) {\n        var cm = this.cm6;\n        return cm.dispatch({\n            changes: { from: 0, to: cm.state.doc.length, insert: text },\n            selection: EditorSelection.range(0, 0)\n        });\n    }\n    ;\n    focus() {\n        return this.cm6.focus();\n    }\n    ;\n    blur() {\n        return this.cm6.contentDOM.blur();\n    }\n    ;\n    defaultTextHeight() {\n        return this.cm6.defaultLineHeight;\n    }\n    ;\n    findMatchingBracket(pos, _options) {\n        var state = this.cm6.state;\n        var offset = indexFromPos(state.doc, pos);\n        var m = matchBrackets(state, offset + 1, -1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        m = matchBrackets(state, offset, 1);\n        if (m && m.end) {\n            return { to: posFromIndex(state.doc, m.end.from) };\n        }\n        return { to: undefined };\n    }\n    ;\n    scanForBracket(pos, dir, style, config) {\n        return scanForBracket(this, pos, dir, style, config);\n    }\n    ;\n    indentLine(line, more) {\n        // todo how to indent only one line instead of selection\n        if (more)\n            this.indentMore();\n        else\n            this.indentLess();\n    }\n    ;\n    indentMore() {\n        indentMore(this.cm6);\n    }\n    ;\n    indentLess() {\n        indentLess(this.cm6);\n    }\n    ;\n    execCommand(name) {\n        if (name == \"indentAuto\")\n            CodeMirror.commands.indentAuto(this);\n        else if (name == \"goLineLeft\")\n            cursorLineBoundaryBackward(this.cm6);\n        else if (name == \"goLineRight\") {\n            cursorLineBoundaryForward(this.cm6);\n            let state = this.cm6.state;\n            let cur = state.selection.main.head;\n            if (cur < state.doc.length && state.sliceDoc(cur, cur + 1) !== \"\\n\") {\n                cursorCharBackward(this.cm6);\n            }\n        }\n        else\n            console.log(name + \" is not implemented\");\n    }\n    ;\n    setBookmark(cursor, options) {\n        var assoc = (options === null || options === void 0 ? void 0 : options.insertLeft) ? 1 : -1;\n        var offset = this.indexFromPos(cursor);\n        var bm = new Marker(this, offset, assoc);\n        return bm;\n    }\n    ;\n    addOverlay({ query }) {\n        let cm6Query = new SearchQuery({\n            regexp: true,\n            search: query.source,\n            caseSensitive: !/i/.test(query.flags),\n        });\n        if (cm6Query.valid) {\n            cm6Query.forVim = true;\n            this.cm6Query = cm6Query;\n            let effect = setSearchQuery.of(cm6Query);\n            this.cm6.dispatch({ effects: effect });\n            return cm6Query;\n        }\n    }\n    ;\n    removeOverlay(overlay) {\n        if (!this.cm6Query)\n            return;\n        this.cm6Query.forVim = false;\n        let effect = setSearchQuery.of(this.cm6Query);\n        this.cm6.dispatch({ effects: effect });\n    }\n    ;\n    getSearchCursor(query, pos) {\n        var cm = this;\n        var last = null;\n        var lastCM5Result = null;\n        if (pos.ch == undefined)\n            pos.ch = Number.MAX_VALUE;\n        var firstOffset = indexFromPos(cm.cm6.state.doc, pos);\n        var source = query.source.replace(/(\\\\.|{(?:\\d+(?:,\\d*)?|,\\d+)})|[{}]/g, function (a, b) {\n            if (!b)\n                return \"\\\\\" + a;\n            return b;\n        });\n        function rCursor(doc, from = 0, to = doc.length) {\n            return new RegExpCursor(doc, source, { ignoreCase: query.ignoreCase }, from, to);\n        }\n        function nextMatch(from) {\n            var doc = cm.cm6.state.doc;\n            if (from > doc.length)\n                return null;\n            let res = rCursor(doc, from).next();\n            return res.done ? null : res.value;\n        }\n        var ChunkSize = 10000;\n        function prevMatchInRange(from, to) {\n            var doc = cm.cm6.state.doc;\n            for (let size = 1;; size++) {\n                let start = Math.max(from, to - size * ChunkSize);\n                let cursor = rCursor(doc, start, to), range = null;\n                while (!cursor.next().done)\n                    range = cursor.value;\n                if (range && (start == from || range.from > start + 10))\n                    return range;\n                if (start == from)\n                    return null;\n            }\n        }\n        return {\n            findNext: function () { return this.find(false); },\n            findPrevious: function () { return this.find(true); },\n            find: function (back) {\n                var doc = cm.cm6.state.doc;\n                if (back) {\n                    let endAt = last ? (last.from == last.to ? last.to - 1 : last.from) : firstOffset;\n                    last = prevMatchInRange(0, endAt);\n                }\n                else {\n                    let startFrom = last ? (last.from == last.to ? last.to + 1 : last.to) : firstOffset;\n                    last = nextMatch(startFrom);\n                }\n                lastCM5Result = last && {\n                    from: posFromIndex(doc, last.from),\n                    to: posFromIndex(doc, last.to),\n                    match: last.match,\n                };\n                return last && last.match;\n            },\n            from: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.from; },\n            to: function () { return lastCM5Result === null || lastCM5Result === void 0 ? void 0 : lastCM5Result.to; },\n            replace: function (text) {\n                if (last) {\n                    dispatchChange(cm, {\n                        changes: { from: last.from, to: last.to, insert: text }\n                    });\n                    last.to = last.from + text.length;\n                    if (lastCM5Result) {\n                        lastCM5Result.to = posFromIndex(cm.cm6.state.doc, last.to);\n                    }\n                }\n            }\n        };\n    }\n    ;\n    findPosV(start, amount, unit, goalColumn) {\n        let { cm6 } = this;\n        const doc = cm6.state.doc;\n        let pixels = unit == 'page' ? cm6.dom.clientHeight : 0;\n        const startOffset = indexFromPos(doc, start);\n        let range = EditorSelection.cursor(startOffset, 1, undefined, goalColumn);\n        let count = Math.round(Math.abs(amount));\n        for (let i = 0; i < count; i++) {\n            if (unit == 'page') {\n                range = cm6.moveVertically(range, amount > 0, pixels);\n            }\n            else if (unit == 'line') {\n                range = cm6.moveVertically(range, amount > 0);\n            }\n        }\n        let pos = posFromIndex(doc, range.head);\n        // set hitside to true if there was no place to move and cursor was clipped to the edge\n        // of document. Needed for gj/gk\n        if ((amount < 0 &&\n            range.head == 0 && goalColumn != 0 &&\n            start.line == 0 && start.ch != 0) || (amount > 0 &&\n            range.head == doc.length && pos.ch != goalColumn\n            && start.line == pos.line)) {\n            pos.hitSide = true;\n        }\n        return pos;\n    }\n    ;\n    charCoords(pos, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = indexFromPos(this.cm6.state.doc, pos);\n        var coords = this.cm6.coordsAtPos(offset);\n        var d = -rect.top;\n        return { left: ((coords === null || coords === void 0 ? void 0 : coords.left) || 0) - rect.left, top: ((coords === null || coords === void 0 ? void 0 : coords.top) || 0) + d, bottom: ((coords === null || coords === void 0 ? void 0 : coords.bottom) || 0) + d };\n    }\n    ;\n    coordsChar(coords, mode) {\n        var rect = this.cm6.contentDOM.getBoundingClientRect();\n        var offset = this.cm6.posAtCoords({ x: coords.left + rect.left, y: coords.top + rect.top }) || 0;\n        return posFromIndex(this.cm6.state.doc, offset);\n    }\n    ;\n    getScrollInfo() {\n        var scroller = this.cm6.scrollDOM;\n        return {\n            left: scroller.scrollLeft, top: scroller.scrollTop,\n            height: scroller.scrollHeight,\n            width: scroller.scrollWidth,\n            clientHeight: scroller.clientHeight, clientWidth: scroller.clientWidth\n        };\n    }\n    ;\n    scrollTo(x, y) {\n        if (x != null)\n            this.cm6.scrollDOM.scrollLeft = x;\n        if (y != null)\n            this.cm6.scrollDOM.scrollTop = y;\n    }\n    ;\n    scrollIntoView(pos, margin) {\n        if (pos) {\n            var offset = this.indexFromPos(pos);\n            this.cm6.dispatch({\n                effects: EditorView.scrollIntoView(offset)\n            });\n        }\n        else {\n            this.cm6.dispatch({ scrollIntoView: true, userEvent: \"scroll\" });\n        }\n    }\n    ;\n    getWrapperElement() {\n        return this.cm6.dom;\n    }\n    ;\n    // for tests\n    getMode() {\n        return { name: this.getOption(\"mode\") };\n    }\n    ;\n    setSize(w, h) {\n        this.cm6.dom.style.width = w + 4 + \"px\";\n        this.cm6.dom.style.height = h + \"px\";\n        this.refresh();\n    }\n    refresh() {\n        this.cm6.measure();\n    }\n    // event listeners\n    destroy() {\n        this.removeOverlay();\n    }\n    ;\n    getLastEditEnd() {\n        return this.posFromIndex(this.$lastChangeEndOffset);\n    }\n    ;\n    onChange(update) {\n        if (this.$lineHandleChanges) {\n            this.$lineHandleChanges.push(update);\n        }\n        for (let i in this.marks) {\n            let m = this.marks[i];\n            m.update(update.changes);\n        }\n        if (this.virtualSelection) {\n            this.virtualSelection.ranges = this.virtualSelection.ranges.map(range => range.map(update.changes));\n        }\n        var curOp = this.curOp = this.curOp || {};\n        update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n            if (curOp.$changeStart == null || curOp.$changeStart > fromB)\n                curOp.$changeStart = fromB;\n            this.$lastChangeEndOffset = toB;\n            var change = { text: text.toJSON() };\n            if (!curOp.lastChange) {\n                curOp.lastChange = curOp.change = change;\n            }\n            else {\n                curOp.lastChange.next = curOp.lastChange = change;\n            }\n        }, true);\n        if (!curOp.changeHandlers)\n            curOp.changeHandlers = this._handlers[\"change\"] && this._handlers[\"change\"].slice();\n    }\n    ;\n    onSelectionChange() {\n        var curOp = this.curOp = this.curOp || {};\n        if (!curOp.cursorActivityHandlers)\n            curOp.cursorActivityHandlers = this._handlers[\"cursorActivity\"] && this._handlers[\"cursorActivity\"].slice();\n        this.curOp.cursorActivity = true;\n    }\n    ;\n    operation(fn, force) {\n        if (!this.curOp)\n            this.curOp = { $d: 0 };\n        this.curOp.$d++;\n        try {\n            var result = fn();\n        }\n        finally {\n            if (this.curOp) {\n                this.curOp.$d--;\n                if (!this.curOp.$d)\n                    this.onBeforeEndOperation();\n            }\n        }\n        return result;\n    }\n    ;\n    onBeforeEndOperation() {\n        var op = this.curOp;\n        var scrollIntoView = false;\n        if (op) {\n            if (op.change) {\n                signalTo(op.changeHandlers, this, op.change);\n            }\n            if (op && op.cursorActivity) {\n                signalTo(op.cursorActivityHandlers, this, null);\n                if (op.isVimOp)\n                    scrollIntoView = true;\n            }\n            this.curOp = null;\n        }\n        if (scrollIntoView)\n            this.scrollIntoView();\n    }\n    ;\n    moveH(increment, unit) {\n        if (unit == 'char') {\n            // todo\n            var cur = this.getCursor();\n            this.setCursor(cur.line, cur.ch + increment);\n        }\n    }\n    ;\n    setOption(name, val) {\n        switch (name) {\n            case \"keyMap\":\n                this.state.keyMap = val;\n                break;\n            case \"textwidth\":\n                this.state.textwidth = val;\n                break;\n        }\n    }\n    ;\n    getOption(name) {\n        switch (name) {\n            case \"firstLineNumber\": return 1;\n            case \"tabSize\": return this.cm6.state.tabSize || 4;\n            case \"readOnly\": return this.cm6.state.readOnly;\n            case \"indentWithTabs\": return this.cm6.state.facet(indentUnit) == \"\\t\"; // TODO\n            case \"indentUnit\": return this.cm6.state.facet(indentUnit).length || 2;\n            case \"textwidth\": return this.state.textwidth;\n            // for tests\n            case \"keyMap\": return this.state.keyMap || \"vim\";\n        }\n    }\n    ;\n    toggleOverwrite(on) {\n        this.state.overwrite = on;\n    }\n    ;\n    getTokenTypeAt(pos) {\n        var _a;\n        // only comment|string are needed\n        var offset = this.indexFromPos(pos);\n        var tree = ensureSyntaxTree(this.cm6.state, offset);\n        var node = tree === null || tree === void 0 ? void 0 : tree.resolve(offset);\n        var type = ((_a = node === null || node === void 0 ? void 0 : node.type) === null || _a === void 0 ? void 0 : _a.name) || \"\";\n        if (/comment/i.test(type))\n            return \"comment\";\n        if (/string/i.test(type))\n            return \"string\";\n        return \"\";\n    }\n    ;\n    overWriteSelection(text) {\n        var doc = this.cm6.state.doc;\n        var sel = this.cm6.state.selection;\n        var ranges = sel.ranges.map(x => {\n            if (x.empty) {\n                var ch = x.to < doc.length ? doc.sliceString(x.from, x.to + 1) : \"\";\n                if (ch && !/\\n/.test(ch))\n                    return EditorSelection.range(x.from, x.to + 1);\n            }\n            return x;\n        });\n        this.cm6.dispatch({\n            selection: EditorSelection.create(ranges, sel.mainIndex)\n        });\n        this.replaceSelection(text);\n    }\n    /*** multiselect ****/\n    isInMultiSelectMode() {\n        return this.cm6.state.selection.ranges.length > 1;\n    }\n    virtualSelectionMode() {\n        return !!this.virtualSelection;\n    }\n    forEachSelection(command) {\n        var selection = this.cm6.state.selection;\n        this.virtualSelection = EditorSelection.create(selection.ranges, selection.mainIndex);\n        for (var i = 0; i < this.virtualSelection.ranges.length; i++) {\n            var range = this.virtualSelection.ranges[i];\n            if (!range)\n                continue;\n            this.cm6.dispatch({ selection: EditorSelection.create([range]) });\n            command();\n            this.virtualSelection.ranges[i] = this.cm6.state.selection.ranges[0];\n        }\n        this.cm6.dispatch({ selection: this.virtualSelection });\n        this.virtualSelection = null;\n    }\n    hardWrap(options) {\n        return hardWrap(this, options);\n    }\n}\nCodeMirror.isMac = typeof navigator != \"undefined\" && /*@__PURE__*//Mac/.test(navigator.platform);\n// --------------------------\nCodeMirror.Pos = Pos;\nCodeMirror.StringStream = StringStream;\nCodeMirror.commands = {\n    cursorCharLeft: function (cm) { cursorCharLeft(cm.cm6); },\n    redo: function (cm) { runHistoryCommand(cm, false); },\n    undo: function (cm) { runHistoryCommand(cm, true); },\n    newlineAndIndent: function (cm) {\n        insertNewlineAndIndent({\n            state: cm.cm6.state,\n            dispatch: (tr) => {\n                return dispatchChange(cm, tr);\n            }\n        });\n    },\n    indentAuto: function (cm) {\n        indentSelection(cm.cm6);\n    },\n    newlineAndIndentContinueComment: undefined,\n    save: undefined,\n};\nCodeMirror.isWordChar = function (ch) {\n    return wordChar.test(ch);\n};\nCodeMirror.keys = keys;\nCodeMirror.addClass = function (el, str) { };\nCodeMirror.rmClass = function (el, str) { };\nCodeMirror.e_preventDefault = function (e) {\n    e.preventDefault();\n};\nCodeMirror.e_stop = function (e) {\n    var _a, _b;\n    (_a = e === null || e === void 0 ? void 0 : e.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(e);\n    (_b = e === null || e === void 0 ? void 0 : e.preventDefault) === null || _b === void 0 ? void 0 : _b.call(e);\n};\nCodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    var result = CodeMirror.keys[key];\n    if (result)\n        handle(result);\n};\nCodeMirror.on = on;\nCodeMirror.off = off;\nCodeMirror.signal = signal;\nCodeMirror.findMatchingTag = findMatchingTag;\nCodeMirror.findEnclosingTag = findEnclosingTag;\nCodeMirror.keyName = undefined;\n/************* dialog *************/\nfunction dialogDiv(cm, template, bottom) {\n    var dialog = document.createElement(\"div\");\n    dialog.appendChild(template);\n    return dialog;\n}\nfunction closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n        cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n}\nfunction openNotification(cm, template, options) {\n    closeNotification(cm, close);\n    var dialog = dialogDiv(cm, template, options && options.bottom);\n    var closed = false;\n    var doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n    function close() {\n        if (closed)\n            return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.remove();\n        hideDialog(cm, dialog);\n    }\n    dialog.onclick = function (e) {\n        e.preventDefault();\n        close();\n    };\n    showDialog(cm, dialog);\n    if (duration)\n        doneTimer = setTimeout(close, duration);\n    return close;\n}\nfunction showDialog(cm, dialog) {\n    var oldDialog = cm.state.dialog;\n    cm.state.dialog = dialog;\n    if (dialog && oldDialog !== dialog) {\n        if (oldDialog && oldDialog.contains(document.activeElement))\n            cm.focus();\n        if (oldDialog && oldDialog.parentElement) {\n            oldDialog.parentElement.replaceChild(dialog, oldDialog);\n        }\n        else if (oldDialog) {\n            oldDialog.remove();\n        }\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction hideDialog(cm, dialog) {\n    if (cm.state.dialog == dialog) {\n        cm.state.dialog = null;\n        CodeMirror.signal(cm, \"dialog\");\n    }\n}\nfunction openDialog(me, template, callback, options) {\n    if (!options)\n        options = {};\n    closeNotification(me, undefined);\n    var dialog = dialogDiv(me, template, options.bottom);\n    var closed = false;\n    showDialog(me, dialog);\n    function close(newVal) {\n        if (typeof newVal == 'string') {\n            inp.value = newVal;\n        }\n        else {\n            if (closed)\n                return;\n            closed = true;\n            hideDialog(me, dialog);\n            if (!me.state.dialog)\n                me.focus();\n            if (options.onClose)\n                options.onClose(dialog);\n        }\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n        if (options.value) {\n            inp.value = options.value;\n            if (options.selectValueOnOpen !== false)\n                inp.select();\n        }\n        if (options.onInput)\n            CodeMirror.on(inp, \"input\", function (e) { options.onInput(e, inp.value, close); });\n        if (options.onKeyUp)\n            CodeMirror.on(inp, \"keyup\", function (e) { options.onKeyUp(e, inp.value, close); });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n                return;\n            }\n            if (e.keyCode == 13)\n                callback(inp.value);\n            if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n                inp.blur();\n                CodeMirror.e_stop(e);\n                close();\n            }\n        });\n        if (options.closeOnBlur !== false)\n            CodeMirror.on(inp, \"blur\", function () {\n                setTimeout(function () {\n                    if (document.activeElement === inp)\n                        return;\n                    close();\n                });\n            });\n        inp.focus();\n    }\n    return close;\n}\nvar matching = { \"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\" };\nfunction bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/;\n}\nfunction scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n    var stack = [];\n    var re = bracketRegex(config);\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n        : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n        var line = cm.getLine(lineNo);\n        if (!line)\n            continue;\n        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n        if (line.length > maxScanLen)\n            continue;\n        if (lineNo == where.line)\n            pos = where.ch - (dir < 0 ? 1 : 0);\n        for (; pos != end; pos += dir) {\n            var ch = line.charAt(pos);\n            if (re.test(ch) /*&& (style === undefined ||\n                                (cm.getTokenTypeAt(new Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))*/) {\n                var match = matching[ch];\n                if (match && (match.charAt(1) == \">\") == (dir > 0))\n                    stack.push(ch);\n                else if (!stack.length)\n                    return { pos: new Pos(lineNo, pos), ch: ch };\n                else\n                    stack.pop();\n            }\n        }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n}\nfunction findMatchingTag(cm, pos) {\n}\nfunction findEnclosingTag(cm, pos) {\n    var _a, _b;\n    var state = cm.cm6.state;\n    var offset = cm.indexFromPos(pos);\n    if (offset < state.doc.length) {\n        var text = state.sliceDoc(offset, offset + 1);\n        if (text == \"<\")\n            offset++;\n    }\n    var tree = ensureSyntaxTree(state, offset);\n    var node = (tree === null || tree === void 0 ? void 0 : tree.resolve(offset)) || null;\n    while (node) {\n        if (((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) == 'OpenTag'\n            && ((_b = node.lastChild) === null || _b === void 0 ? void 0 : _b.type.name) == 'CloseTag') {\n            return {\n                open: convertRange(state.doc, node.firstChild),\n                close: convertRange(state.doc, node.lastChild),\n            };\n        }\n        node = node.parent;\n    }\n}\nfunction convertRange(doc, cm6Range) {\n    return {\n        from: posFromIndex(doc, cm6Range.from),\n        to: posFromIndex(doc, cm6Range.to)\n    };\n}\nclass Marker {\n    constructor(cm, offset, assoc) {\n        this.cm = cm;\n        this.id = cm.$mid++;\n        this.offset = offset;\n        this.assoc = assoc;\n        cm.marks[this.id] = this;\n    }\n    ;\n    clear() { delete this.cm.marks[this.id]; }\n    ;\n    find() {\n        if (this.offset == null)\n            return null;\n        return this.cm.posFromIndex(this.offset);\n    }\n    ;\n    update(change) {\n        if (this.offset != null)\n            this.offset = change.mapPos(this.offset, this.assoc, MapMode.TrackDel);\n    }\n}\nfunction hardWrap(cm, options) {\n    var _a;\n    var max = options.column || cm.getOption('textwidth') || 80;\n    var allowMerge = options.allowMerge != false;\n    var row = Math.min(options.from, options.to);\n    var endRow = Math.max(options.from, options.to);\n    while (row <= endRow) {\n        var line = cm.getLine(row);\n        if (line.length > max) {\n            var space = findSpace(line, max, 5);\n            if (space) {\n                var indentation = (_a = /^\\s*/.exec(line)) === null || _a === void 0 ? void 0 : _a[0];\n                cm.replaceRange(\"\\n\" + indentation, new Pos(row, space.start), new Pos(row, space.end));\n            }\n            endRow++;\n        }\n        else if (allowMerge && /\\S/.test(line) && row != endRow) {\n            var nextLine = cm.getLine(row + 1);\n            if (nextLine && /\\S/.test(nextLine)) {\n                var trimmedLine = line.replace(/\\s+$/, \"\");\n                var trimmedNextLine = nextLine.replace(/^\\s+/, \"\");\n                var mergedLine = trimmedLine + \" \" + trimmedNextLine;\n                var space = findSpace(mergedLine, max, 5);\n                if (space && space.start > trimmedLine.length || mergedLine.length < max) {\n                    cm.replaceRange(\" \", new Pos(row, trimmedLine.length), new Pos(row + 1, nextLine.length - trimmedNextLine.length));\n                    row--;\n                    endRow--;\n                }\n                else if (trimmedLine.length < line.length) {\n                    cm.replaceRange(\"\", new Pos(row, trimmedLine.length), new Pos(row, line.length));\n                }\n            }\n        }\n        row++;\n    }\n    return row;\n    function findSpace(line, max, min) {\n        if (line.length < max)\n            return;\n        var before = line.slice(0, max);\n        var after = line.slice(max);\n        var spaceAfter = /^(?:(\\s+)|(\\S+)(\\s+))/.exec(after);\n        var spaceBefore = /(?:(\\s+)|(\\s+)(\\S+))$/.exec(before);\n        var start = 0;\n        var end = 0;\n        if (spaceBefore && !spaceBefore[2]) {\n            start = max - spaceBefore[1].length;\n            end = max;\n        }\n        if (spaceAfter && !spaceAfter[2]) {\n            if (!start)\n                start = max;\n            end = max + spaceAfter[1].length;\n        }\n        if (start) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        if (spaceBefore && spaceBefore[2] && spaceBefore.index > min) {\n            return {\n                start: spaceBefore.index,\n                end: spaceBefore.index + spaceBefore[2].length\n            };\n        }\n        if (spaceAfter && spaceAfter[2]) {\n            start = max + spaceAfter[2].length;\n            return {\n                start: start,\n                end: start + spaceAfter[3].length\n            };\n        }\n    }\n}\n\n// backwards compatibility for old versions not supporting getDrawSelectionConfig\nlet getDrawSelectionConfig = View.getDrawSelectionConfig || /*@__PURE__*/function () {\n    let defaultConfig = { cursorBlinkRate: 1200 };\n    return function () {\n        return defaultConfig;\n    };\n}();\nclass Piece {\n    constructor(left, top, height, fontFamily, fontSize, fontWeight, color, className, letter, partial) {\n        this.left = left;\n        this.top = top;\n        this.height = height;\n        this.fontFamily = fontFamily;\n        this.fontSize = fontSize;\n        this.fontWeight = fontWeight;\n        this.color = color;\n        this.className = className;\n        this.letter = letter;\n        this.partial = partial;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        elt.style.height = this.height + \"px\";\n        elt.style.lineHeight = this.height + \"px\";\n        elt.style.fontFamily = this.fontFamily;\n        elt.style.fontSize = this.fontSize;\n        elt.style.fontWeight = this.fontWeight;\n        elt.style.color = this.partial ? \"transparent\" : this.color;\n        elt.className = this.className;\n        elt.textContent = this.letter;\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.height == p.height &&\n            this.fontFamily == p.fontFamily && this.fontSize == p.fontSize &&\n            this.fontWeight == p.fontWeight && this.color == p.color &&\n            this.className == p.className &&\n            this.letter == p.letter;\n    }\n}\nclass BlockCursorPlugin {\n    constructor(view, cm) {\n        this.view = view;\n        this.rangePieces = [];\n        this.cursors = [];\n        this.cm = cm;\n        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };\n        this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.cursorLayer.className = \"cm-cursorLayer cm-vimCursorLayer\";\n        this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n        view.requestMeasure(this.measureReq);\n        this.setBlinkRate();\n    }\n    setBlinkRate() {\n        let config = getDrawSelectionConfig(this.cm.cm6.state);\n        let blinkRate = config.cursorBlinkRate;\n        this.cursorLayer.style.animationDuration = blinkRate + \"ms\";\n    }\n    update(update) {\n        if (update.selectionSet || update.geometryChanged || update.viewportChanged) {\n            this.view.requestMeasure(this.measureReq);\n            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        }\n        if (configChanged(update))\n            this.setBlinkRate();\n    }\n    scheduleRedraw() {\n        this.view.requestMeasure(this.measureReq);\n    }\n    readPos() {\n        let { state } = this.view;\n        let cursors = [];\n        for (let r of state.selection.ranges) {\n            let prim = r == state.selection.main;\n            let piece = measureCursor(this.cm, this.view, r, prim);\n            if (piece)\n                cursors.push(piece);\n        }\n        return { cursors };\n    }\n    drawSel({ cursors }) {\n        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {\n            let oldCursors = this.cursorLayer.children;\n            if (oldCursors.length !== cursors.length) {\n                this.cursorLayer.textContent = \"\";\n                for (const c of cursors)\n                    this.cursorLayer.appendChild(c.draw());\n            }\n            else {\n                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));\n            }\n            this.cursors = cursors;\n        }\n    }\n    destroy() {\n        this.cursorLayer.remove();\n    }\n}\nfunction configChanged(update) {\n    return getDrawSelectionConfig(update.startState) != getDrawSelectionConfig(update.state);\n}\nconst themeSpec = {\n    \".cm-vimMode .cm-line\": {\n        \"& ::selection\": { backgroundColor: \"transparent !important\" },\n        \"&::selection\": { backgroundColor: \"transparent !important\" },\n        caretColor: \"transparent !important\",\n    },\n    \".cm-fat-cursor\": {\n        position: \"absolute\",\n        background: \"#ff9696\",\n        border: \"none\",\n        whiteSpace: \"pre\",\n    },\n    \"&:not(.cm-focused) .cm-fat-cursor\": {\n        background: \"none\",\n        outline: \"solid 1px #ff9696\",\n        color: \"transparent !important\",\n    },\n};\nconst hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };\n}\nfunction measureCursor(cm, view, cursor, primary) {\n    var _a, _b;\n    let head = cursor.head;\n    let fatCursor = false;\n    let hCoeff = 1;\n    let vim = cm.state.vim;\n    if (vim && (!vim.insertMode || cm.state.overwrite)) {\n        fatCursor = true;\n        if (vim.visualBlock && !primary)\n            return null;\n        if (cursor.anchor < cursor.head)\n            head--;\n        if (cm.state.overwrite)\n            hCoeff = 0.2;\n        else if (vim.status)\n            hCoeff = 0.5;\n    }\n    if (fatCursor) {\n        let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);\n        if (letter && (/[\\uDC00-\\uDFFF]/.test(letter) && head > 1)) {\n            // step back if cursor is on the second half of a surrogate pair\n            head--;\n            letter = view.state.sliceDoc(head, head + 1);\n        }\n        let pos = view.coordsAtPos(head, 1);\n        if (!pos)\n            return null;\n        let base = getBase(view);\n        let domAtPos = view.domAtPos(head);\n        let node = domAtPos ? domAtPos.node : view.contentDOM;\n        while (domAtPos && domAtPos.node instanceof HTMLElement) {\n            node = domAtPos.node;\n            domAtPos = { node: domAtPos.node.childNodes[domAtPos.offset], offset: 0 };\n        }\n        if (!(node instanceof HTMLElement)) {\n            if (!node.parentNode)\n                return null;\n            node = node.parentNode;\n        }\n        let style = getComputedStyle(node);\n        let left = pos.left;\n        // TODO remove coordsAtPos when all supported versions of codemirror have coordsForChar api\n        let charCoords = (_b = (_a = view).coordsForChar) === null || _b === void 0 ? void 0 : _b.call(_a, head);\n        if (charCoords) {\n            left = charCoords.left;\n        }\n        if (!letter || letter == \"\\n\" || letter == \"\\r\") {\n            letter = \"\\xa0\";\n        }\n        else if (letter == \"\\t\") {\n            letter = \"\\xa0\";\n            var nextPos = view.coordsAtPos(head + 1, -1);\n            if (nextPos) {\n                left = nextPos.left - (nextPos.left - pos.left) / parseInt(style.tabSize);\n            }\n        }\n        else if ((/[\\uD800-\\uDBFF]/.test(letter) && head < view.state.doc.length - 1)) {\n            // include the second half of a surrogate pair in cursor\n            letter += view.state.sliceDoc(head + 1, head + 2);\n        }\n        let h = (pos.bottom - pos.top);\n        return new Piece(left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, style.fontFamily, style.fontSize, style.fontWeight, style.color, primary ? \"cm-fat-cursor cm-cursor-primary\" : \"cm-fat-cursor cm-cursor-secondary\", letter, hCoeff != 1);\n    }\n    else {\n        return null;\n    }\n}\n\nvar FIREFOX_LINUX = typeof navigator != \"undefined\"\n    && /*@__PURE__*//linux/i.test(navigator.platform)\n    && /*@__PURE__*// Gecko\\/\\d+/.exec(navigator.userAgent);\nconst Vim = /*@__PURE__*/initVim(CodeMirror);\nconst HighlightMargin = 250;\nconst vimStyle = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-vimMode .cm-cursorLayer:not(.cm-vimCursorLayer)\": {\n        display: \"none\",\n    },\n    \".cm-vim-panel\": {\n        padding: \"0px 10px\",\n        fontFamily: \"monospace\",\n        minHeight: \"1.3em\",\n    },\n    \".cm-vim-panel input\": {\n        border: \"none\",\n        outline: \"none\",\n        backgroundColor: \"inherit\",\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n});\nconst vimPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.status = \"\";\n        this.query = null;\n        this.decorations = Decoration.none;\n        this.waitForCopy = false;\n        this.lastKeydown = '';\n        this.useNextTextInput = false;\n        this.compositionText = '';\n        this.view = view;\n        const cm = (this.cm = new CodeMirror(view));\n        Vim.enterVimMode(this.cm);\n        this.view.cm = this.cm;\n        this.cm.state.vimPlugin = this;\n        this.blockCursor = new BlockCursorPlugin(view, cm);\n        this.updateClass();\n        this.cm.on(\"vim-command-done\", () => {\n            if (cm.state.vim)\n                cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateStatus();\n        });\n        this.cm.on(\"vim-mode-change\", (e) => {\n            if (!cm.state.vim)\n                return;\n            cm.state.vim.mode = e.mode;\n            if (e.subMode) {\n                cm.state.vim.mode += \" block\";\n            }\n            cm.state.vim.status = \"\";\n            this.blockCursor.scheduleRedraw();\n            this.updateClass();\n            this.updateStatus();\n        });\n        this.cm.on(\"dialog\", () => {\n            if (this.cm.state.statusbar) {\n                this.updateStatus();\n            }\n            else {\n                view.dispatch({\n                    effects: showVimPanel.of(!!this.cm.state.dialog),\n                });\n            }\n        });\n        this.dom = document.createElement(\"span\");\n        this.dom.style.cssText = \"position: absolute; right: 10px; top: 1px\";\n        this.statusButton = document.createElement(\"span\");\n        this.statusButton.onclick = (e) => {\n            Vim.handleKey(this.cm, \"<Esc>\", \"user\");\n            this.cm.focus();\n        };\n        this.statusButton.style.cssText = \"cursor: pointer\";\n    }\n    update(update) {\n        var _a;\n        if ((update.viewportChanged || update.docChanged) && this.query) {\n            this.highlight(this.query);\n        }\n        if (update.docChanged) {\n            this.cm.onChange(update);\n        }\n        if (update.selectionSet) {\n            this.cm.onSelectionChange();\n        }\n        if (update.viewportChanged) ;\n        if (this.cm.curOp && !this.cm.curOp.isVimOp) {\n            this.cm.onBeforeEndOperation();\n        }\n        if (update.transactions) {\n            for (let tr of update.transactions)\n                for (let effect of tr.effects) {\n                    if (effect.is(setSearchQuery)) {\n                        let forVim = (_a = effect.value) === null || _a === void 0 ? void 0 : _a.forVim;\n                        if (!forVim) {\n                            this.highlight(null);\n                        }\n                        else {\n                            let query = effect.value.create();\n                            this.highlight(query);\n                        }\n                    }\n                }\n        }\n        this.blockCursor.update(update);\n    }\n    updateClass() {\n        const state = this.cm.state;\n        if (!state.vim || (state.vim.insertMode && !state.overwrite))\n            this.view.scrollDOM.classList.remove(\"cm-vimMode\");\n        else\n            this.view.scrollDOM.classList.add(\"cm-vimMode\");\n    }\n    updateStatus() {\n        let dom = this.cm.state.statusbar;\n        let vim = this.cm.state.vim;\n        if (!dom || !vim)\n            return;\n        let dialog = this.cm.state.dialog;\n        if (dialog) {\n            if (dialog.parentElement != dom) {\n                dom.textContent = \"\";\n                dom.appendChild(dialog);\n            }\n        }\n        else {\n            dom.textContent = \"\";\n            var status = (vim.mode || \"normal\").toUpperCase();\n            if (vim.insertModeReturn)\n                status += \"(C-O)\";\n            this.statusButton.textContent = `--${status}--`;\n            dom.appendChild(this.statusButton);\n        }\n        this.dom.textContent = vim.status;\n        dom.appendChild(this.dom);\n    }\n    destroy() {\n        Vim.leaveVimMode(this.cm);\n        this.updateClass();\n        this.blockCursor.destroy();\n        delete this.view.cm;\n    }\n    highlight(query) {\n        this.query = query;\n        if (!query)\n            return (this.decorations = Decoration.none);\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * HighlightMargin)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                builder.add(from, to, matchMark);\n            });\n        }\n        return (this.decorations = builder.finish());\n    }\n    handleKey(e, view) {\n        const cm = this.cm;\n        let vim = cm.state.vim;\n        if (!vim)\n            return;\n        const key = Vim.vimKeyFromEvent(e, vim);\n        CodeMirror.signal(this.cm, 'inputEvent', { type: \"handleKey\", key });\n        if (!key)\n            return;\n        // clear search highlight\n        if (key == \"<Esc>\" &&\n            !vim.insertMode &&\n            !vim.visualMode &&\n            this.query /* && !cm.inMultiSelectMode*/) {\n            const searchState = vim.searchState_;\n            if (searchState) {\n                cm.removeOverlay(searchState.getOverlay());\n                searchState.setOverlay(null);\n            }\n        }\n        let isCopy = key === \"<C-c>\" && !CodeMirror.isMac;\n        if (isCopy && cm.somethingSelected()) {\n            this.waitForCopy = true;\n            return true;\n        }\n        vim.status = (vim.status || \"\") + key;\n        let result = Vim.multiSelectHandleKey(cm, key, \"user\");\n        vim = Vim.maybeInitVimState_(cm); // the object can change if there is an exception in handleKey\n        // insert mode\n        if (!result && vim.insertMode && cm.state.overwrite) {\n            if (e.key && e.key.length == 1 && !/\\n/.test(e.key)) {\n                result = true;\n                cm.overWriteSelection(e.key);\n            }\n            else if (e.key == \"Backspace\") {\n                result = true;\n                CodeMirror.commands.cursorCharLeft(cm);\n            }\n        }\n        if (result) {\n            CodeMirror.signal(this.cm, 'vim-keypress', key);\n            e.preventDefault();\n            e.stopPropagation();\n            this.blockCursor.scheduleRedraw();\n        }\n        this.updateStatus();\n        return !!result;\n    }\n}, {\n    eventHandlers: {\n        copy: function (e, view) {\n            if (!this.waitForCopy)\n                return;\n            this.waitForCopy = false;\n            Promise.resolve().then(() => {\n                var cm = this.cm;\n                var vim = cm.state.vim;\n                if (!vim)\n                    return;\n                if (vim.insertMode) {\n                    cm.setSelection(cm.getCursor(), cm.getCursor());\n                }\n                else {\n                    cm.operation(() => {\n                        if (cm.curOp)\n                            cm.curOp.isVimOp = true;\n                        Vim.handleKey(cm, '<Esc>', 'user');\n                    });\n                }\n            });\n        },\n        compositionstart: function (e, view) {\n            this.useNextTextInput = true;\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n        },\n        compositionupdate: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n        },\n        compositionend: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n        },\n        keypress: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n            if (this.lastKeydown == \"Dead\")\n                this.handleKey(e, view);\n        },\n        keydown: function (e, view) {\n            CodeMirror.signal(this.cm, 'inputEvent', e);\n            this.lastKeydown = e.key;\n            if (this.lastKeydown == \"Unidentified\"\n                || this.lastKeydown == \"Process\"\n                || this.lastKeydown == \"Dead\") {\n                this.useNextTextInput = true;\n            }\n            else {\n                this.useNextTextInput = false;\n                this.handleKey(e, view);\n            }\n        },\n    },\n    provide: () => {\n        return [\n            EditorView.inputHandler.of((view, from, to, text) => {\n                var _a, _b;\n                var cm = getCM(view);\n                if (!cm)\n                    return false;\n                var vim = (_a = cm.state) === null || _a === void 0 ? void 0 : _a.vim;\n                var vimPlugin = cm.state.vimPlugin;\n                if (vim && !vim.insertMode && !((_b = cm.curOp) === null || _b === void 0 ? void 0 : _b.isVimOp)) {\n                    if (text === \"\\0\\0\") {\n                        return true;\n                    }\n                    CodeMirror.signal(cm, 'inputEvent', {\n                        type: \"text\",\n                        text,\n                        from,\n                        to,\n                    });\n                    if (text.length == 1 && vimPlugin.useNextTextInput) {\n                        if (vim.expectLiteralNext && view.composing) {\n                            vimPlugin.compositionText = text;\n                            return false;\n                        }\n                        if (vimPlugin.compositionText) {\n                            var toRemove = vimPlugin.compositionText;\n                            vimPlugin.compositionText = '';\n                            var head = view.state.selection.main.head;\n                            var textInDoc = view.state.sliceDoc(head - toRemove.length, head);\n                            if (toRemove === textInDoc) {\n                                var pos = cm.getCursor();\n                                cm.replaceRange('', cm.posFromIndex(head - toRemove.length), pos);\n                            }\n                        }\n                        vimPlugin.handleKey({\n                            key: text,\n                            preventDefault: () => { },\n                            stopPropagation: () => { }\n                        });\n                        forceEndComposition(view);\n                        return true;\n                    }\n                }\n                return false;\n            })\n        ];\n    },\n    decorations: (v) => v.decorations,\n});\n/**\n * removes contenteditable element and adds it back to end\n * IME composition in normal mode\n * this method works on all browsers except for Firefox on Linux\n * where we need to reset textContent of editor\n * (which doesn't work on other browsers)\n */\nfunction forceEndComposition(view) {\n    var parent = view.scrollDOM.parentElement;\n    if (!parent)\n        return;\n    if (FIREFOX_LINUX) {\n        view.contentDOM.textContent = \"\\0\\0\";\n        view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n        return;\n    }\n    var sibling = view.scrollDOM.nextSibling;\n    var selection = window.getSelection();\n    var savedSelection = selection && {\n        anchorNode: selection.anchorNode,\n        anchorOffset: selection.anchorOffset,\n        focusNode: selection.focusNode,\n        focusOffset: selection.focusOffset\n    };\n    view.scrollDOM.remove();\n    parent.insertBefore(view.scrollDOM, sibling);\n    try {\n        if (savedSelection && selection) {\n            selection.setPosition(savedSelection.anchorNode, savedSelection.anchorOffset);\n            if (savedSelection.focusNode) {\n                selection.extend(savedSelection.focusNode, savedSelection.focusOffset);\n            }\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n    view.focus();\n    view.contentDOM.dispatchEvent(new CustomEvent(\"compositionend\"));\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" });\nconst showVimPanel = /*@__PURE__*/StateEffect.define();\nconst vimPanelState = /*@__PURE__*/StateField.define({\n    create: () => false,\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(showVimPanel))\n                value = e.value;\n        return value;\n    },\n    provide: (f) => {\n        return showPanel.from(f, (on) => (on ? createVimPanel : null));\n    },\n});\nfunction createVimPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    if (cm.state.dialog) {\n        dom.appendChild(cm.state.dialog);\n    }\n    return { top: false, dom };\n}\nfunction statusPanel(view) {\n    let dom = document.createElement(\"div\");\n    dom.className = \"cm-vim-panel\";\n    let cm = view.cm;\n    cm.state.statusbar = dom;\n    cm.state.vimPlugin.updateStatus();\n    return { dom };\n}\nfunction vim(options = {}) {\n    return [\n        vimStyle,\n        vimPlugin,\n        hideNativeSelection,\n        options.status ? showPanel.of(statusPanel) : vimPanelState,\n    ];\n}\nfunction getCM(view) {\n    return view.cm || null;\n}\n\nexport { CodeMirror, Vim, getCM, vim };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}